CCS PCM C Compiler, Version 5.092, 43599               14-Mar-21 13:06

               Filename:   C:\Users\HOANGLONG\Desktop\RFID L298\CODE RFID\main.lst

               ROM used:   4500 words (55%)
                           Largest free fragment is 2048
               RAM used:   78 (21%) at main() level
                           119 (32%) worst case
               Stack used: 9 locations
               Stack size: 8

0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <main.h>
.................... #include <16F887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA A0,22
000D:  DATA 4E,2A
000E:  DATA 45,29
000F:  DATA 20,27
0010:  DATA C5,2B
0011:  DATA 20,28
0012:  DATA C1,29
0013:  DATA 53,10
0014:  DATA 00,00
0015:  DATA 20,10
0016:  DATA 20,10
0017:  DATA D7,22
0018:  DATA CC,21
0019:  DATA CF,26
001A:  DATA C5,10
001B:  DATA 00,01
001C:  DATA 20,10
001D:  DATA C4,27
001E:  DATA 4F,29
001F:  DATA 20,10
0020:  DATA 20,26
0021:  DATA CF,21
0022:  DATA 4B,10
0023:  DATA 20,10
0024:  DATA 00,01
0025:  DATA 50,29
0026:  DATA C5,29
0027:  DATA 53,10
0028:  DATA 23,10
0029:  DATA D4,27
002A:  DATA 20,24
002B:  DATA 45,26
002C:  DATA D0,10
002D:  DATA 00,01
002E:  DATA A0,22
002F:  DATA 4E,2A
0030:  DATA 45,29
0031:  DATA A0,27
0032:  DATA 4C,22
0033:  DATA 20,28
0034:  DATA C1,29
0035:  DATA 53,10
0036:  DATA 00,01
0037:  DATA 20,10
0038:  DATA 20,10
0039:  DATA 20,10
003A:  DATA 20,10
003B:  DATA 20,10
003C:  DATA 00,01
003D:  DATA A0,22
003E:  DATA 4E,2A
003F:  DATA 45,29
0040:  DATA 20,27
0041:  DATA C5,2B
0042:  DATA 20,28
0043:  DATA C1,29
0044:  DATA 53,10
0045:  DATA 00,01
0046:  DATA 20,10
0047:  DATA 20,10
0048:  DATA 20,10
0049:  DATA 20,10
004A:  DATA 20,10
004B:  DATA 00,01
004C:  DATA 20,10
004D:  DATA 20,10
004E:  DATA 20,22
004F:  DATA 4F,27
0050:  DATA C5,10
0051:  DATA 20,10
0052:  DATA 20,10
0053:  DATA 20,10
0054:  DATA 00,01
0055:  DATA 20,10
0056:  DATA C4,27
0057:  DATA 4F,29
0058:  DATA 20,10
0059:  DATA 20,26
005A:  DATA CF,21
005B:  DATA 4B,10
005C:  DATA 20,10
005D:  DATA 00,01
005E:  DATA 50,29
005F:  DATA C5,29
0060:  DATA 53,10
0061:  DATA 23,10
0062:  DATA D4,27
0063:  DATA 20,24
0064:  DATA 45,26
0065:  DATA D0,10
0066:  DATA 00,01
0067:  DATA 20,10
0068:  DATA A0,24
0069:  DATA EE,31
006A:  DATA 6F,39
006B:  DATA F2,32
006C:  DATA 63,3A
006D:  DATA 21,10
006E:  DATA 20,10
006F:  DATA 00,01
0070:  DATA 20,10
0071:  DATA 20,2A
0072:  DATA F2,3C
0073:  DATA A0,30
0074:  DATA E7,30
0075:  DATA 69,37
0076:  DATA 21,10
0077:  DATA 20,10
0078:  DATA 00,01
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 20,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 00,01
0082:  DATA 20,10
0083:  DATA 41,22
0084:  DATA 44,10
0085:  DATA CE,22
0086:  DATA 57,10
0087:  DATA C3,20
0088:  DATA 52,22
0089:  DATA 20,10
008A:  DATA 00,01
008B:  DATA 20,10
008C:  DATA 49,27
008D:  DATA D3,22
008E:  DATA 52,2A
008F:  DATA A0,21
0090:  DATA 41,29
0091:  DATA C4,10
0092:  DATA 20,10
0093:  DATA 00,01
0094:  DATA A0,24
0095:  DATA 44,1D
0096:  DATA 20,00
0097:  DATA A0,21
0098:  DATA C8,27
0099:  DATA CF,29
009A:  DATA 45,10
009B:  DATA D0,27
009C:  DATA D3,24
009D:  DATA D4,27
009E:  DATA 4E,10
009F:  DATA 20,00
00A0:  DATA D4,27
00A1:  DATA A0,29
00A2:  DATA 41,2B
00A3:  DATA 45,10
00A4:  DATA C3,20
00A5:  DATA 52,22
00A6:  DATA BA,18
00A7:  DATA AD,1A
00A8:  DATA 00,01
00A9:  DATA 20,10
00AA:  DATA 41,22
00AB:  DATA 44,10
00AC:  DATA CE,22
00AD:  DATA 57,10
00AE:  DATA C3,20
00AF:  DATA 52,22
00B0:  DATA 20,10
00B1:  DATA 00,01
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,22
00B5:  DATA 4F,27
00B6:  DATA C5,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 00,01
00BB:  DATA 20,10
00BC:  DATA C4,27
00BD:  DATA 4F,29
00BE:  DATA 20,10
00BF:  DATA 20,26
00C0:  DATA CF,21
00C1:  DATA 4B,10
00C2:  DATA 20,10
00C3:  DATA 00,01
00C4:  DATA 50,29
00C5:  DATA C5,29
00C6:  DATA 53,10
00C7:  DATA 23,10
00C8:  DATA D4,27
00C9:  DATA 20,24
00CA:  DATA 45,26
00CB:  DATA D0,10
00CC:  DATA 00,01
00CD:  DATA 20,10
00CE:  DATA D2,22
00CF:  DATA CD,27
00D0:  DATA D6,22
00D1:  DATA A0,21
00D2:  DATA 41,29
00D3:  DATA C4,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA 43,24
00D7:  DATA CF,27
00D8:  DATA D3,22
00D9:  DATA A0,21
00DA:  DATA 41,29
00DB:  DATA 44,1D
00DC:  DATA A0,18
00DD:  DATA AD,1A
00DE:  DATA 00,01
00DF:  DATA 20,10
00E0:  DATA 20,10
00E1:  DATA A0,21
00E2:  DATA 41,29
00E3:  DATA 44,10
00E4:  DATA 25,32
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 20,00
00E8:  DATA A0,24
00E9:  DATA 44,1D
00EA:  DATA 20,00
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA C4,22
00EE:  DATA CC,22
00EF:  DATA D4,22
00F0:  DATA C4,10
00F1:  DATA 20,10
00F2:  DATA 20,10
00F3:  DATA 00,00
00F4:  DATA 20,10
00F5:  DATA C4,27
00F6:  DATA 4F,29
00F7:  DATA 20,10
00F8:  DATA 20,26
00F9:  DATA CF,21
00FA:  DATA 4B,10
00FB:  DATA 20,10
00FC:  DATA 00,01
00FD:  DATA 50,29
00FE:  DATA C5,29
00FF:  DATA 53,10
0100:  DATA 23,10
0101:  DATA D4,27
0102:  DATA 20,24
0103:  DATA 45,26
0104:  DATA D0,10
0105:  DATA 00,00
0106:  DATA 20,10
0107:  DATA C4,27
0108:  DATA 4F,29
0109:  DATA 20,10
010A:  DATA 55,27
010B:  DATA CC,27
010C:  DATA C3,25
010D:  DATA 20,10
010E:  DATA 00,01
010F:  DATA 50,29
0110:  DATA C5,29
0111:  DATA 53,10
0112:  DATA 23,10
0113:  DATA D4,27
0114:  DATA 20,24
0115:  DATA 45,26
0116:  DATA D0,10
0117:  DATA 00,00
0118:  DATA A0,22
0119:  DATA 4E,2A
011A:  DATA 45,29
011B:  DATA 20,28
011C:  DATA C1,29
011D:  DATA D3,2B
011E:  DATA 4F,29
011F:  DATA 44,00
0120:  DATA 20,10
0121:  DATA 20,10
0122:  DATA 20,10
0123:  DATA 20,10
0124:  DATA 20,10
0125:  DATA 00,01
0126:  DATA 20,10
0127:  DATA A0,24
0128:  DATA EE,31
0129:  DATA 6F,39
012A:  DATA F2,32
012B:  DATA 63,3A
012C:  DATA 21,10
012D:  DATA 20,10
012E:  DATA 00,01
012F:  DATA 20,10
0130:  DATA 20,2A
0131:  DATA F2,3C
0132:  DATA A0,30
0133:  DATA E7,30
0134:  DATA 69,37
0135:  DATA 21,10
0136:  DATA 20,10
0137:  DATA 00,01
0138:  DATA 20,10
0139:  DATA 20,10
013A:  DATA 20,10
013B:  DATA 20,10
013C:  DATA 20,10
013D:  DATA 20,10
013E:  DATA 20,10
013F:  DATA 20,10
0140:  DATA 00,00
0141:  DATA 20,10
0142:  DATA C8,27
0143:  DATA 57,10
0144:  DATA D4,27
0145:  DATA A0,2A
0146:  DATA D3,22
0147:  DATA 3F,10
0148:  DATA 20,10
0149:  DATA 00,01
014A:  DATA 41,10
014B:  DATA F4,37
014C:  DATA A0,2A
014D:  DATA 4E,26
014E:  DATA CF,21
014F:  DATA 4B,10
0150:  DATA C4,27
0151:  DATA 4F,29
0152:  DATA 00,01
0153:  DATA 42,10
0154:  DATA F4,37
0155:  DATA A0,21
0156:  DATA C8,20
0157:  DATA CE,23
0158:  DATA 45,10
0159:  DATA D0,20
015A:  DATA D3,29
015B:  DATA 00,01
015C:  DATA 43,10
015D:  DATA F4,37
015E:  DATA A0,20
015F:  DATA 44,22
0160:  DATA 20,27
0161:  DATA C5,2B
0162:  DATA C3,20
0163:  DATA 52,22
0164:  DATA 00,01
0165:  DATA 44,10
0166:  DATA F4,37
0167:  DATA 20,29
0168:  DATA C5,26
0169:  DATA 4F,2B
016A:  DATA 45,10
016B:  DATA C3,20
016C:  DATA 52,22
016D:  DATA 00,01
016E:  DATA 2A,10
016F:  DATA F4,37
0170:  DATA A0,21
0171:  DATA CC,22
0172:  DATA 41,29
0173:  DATA 20,28
0174:  DATA C1,29
0175:  DATA 53,10
0176:  DATA 00,01
0177:  DATA 23,10
0178:  DATA F4,37
0179:  DATA A0,22
017A:  DATA D8,24
017B:  DATA 54,10
017C:  DATA 2F,10
017D:  DATA C2,20
017E:  DATA C3,25
017F:  DATA 00,00
*
0454:  BCF    0A.0
0455:  BCF    0A.1
0456:  BSF    0A.2
0457:  ADDWF  02,F
0458:  GOTO   42C
0459:  GOTO   436
045A:  GOTO   440
045B:  GOTO   44A
*
0486:  MOVF   0B,W
0487:  MOVWF  69
0488:  BCF    0B.7
0489:  BSF    03.5
048A:  BSF    03.6
048B:  BSF    0C.7
048C:  BSF    0C.0
048D:  NOP
048E:  NOP
048F:  BCF    03.5
0490:  BCF    03.6
0491:  BTFSC  69.7
0492:  BSF    0B.7
0493:  BSF    03.6
0494:  MOVF   0C,W
0495:  ANDLW  7F
0496:  BTFSC  03.2
0497:  GOTO   4DA
0498:  BCF    03.6
0499:  MOVWF  69
049A:  BSF    03.6
049B:  MOVF   0D,W
049C:  BCF    03.6
049D:  MOVWF  6A
049E:  BSF    03.6
049F:  MOVF   0F,W
04A0:  BCF    03.6
04A1:  MOVWF  6B
04A2:  MOVF   69,W
04A3:  MOVWF  6E
04A4:  CALL   273
04A5:  MOVF   6A,W
04A6:  BSF    03.6
04A7:  MOVWF  0D
04A8:  BCF    03.6
04A9:  MOVF   6B,W
04AA:  BSF    03.6
04AB:  MOVWF  0F
04AC:  BCF    03.6
04AD:  MOVF   0B,W
04AE:  MOVWF  6C
04AF:  BCF    0B.7
04B0:  BSF    03.5
04B1:  BSF    03.6
04B2:  BSF    0C.7
04B3:  BSF    0C.0
04B4:  NOP
04B5:  NOP
04B6:  BCF    03.5
04B7:  BCF    03.6
04B8:  BTFSC  6C.7
04B9:  BSF    0B.7
04BA:  BSF    03.6
04BB:  RLF    0C,W
04BC:  RLF    0E,W
04BD:  ANDLW  7F
04BE:  BTFSC  03.2
04BF:  GOTO   4DA
04C0:  BCF    03.6
04C1:  MOVWF  69
04C2:  BSF    03.6
04C3:  MOVF   0D,W
04C4:  BCF    03.6
04C5:  MOVWF  6A
04C6:  BSF    03.6
04C7:  MOVF   0F,W
04C8:  BCF    03.6
04C9:  MOVWF  6B
04CA:  MOVF   69,W
04CB:  MOVWF  6E
04CC:  CALL   273
04CD:  MOVF   6A,W
04CE:  BSF    03.6
04CF:  MOVWF  0D
04D0:  BCF    03.6
04D1:  MOVF   6B,W
04D2:  BSF    03.6
04D3:  MOVWF  0F
04D4:  INCF   0D,F
04D5:  BTFSC  03.2
04D6:  INCF   0F,F
04D7:  BCF    03.6
04D8:  GOTO   486
04D9:  BSF    03.6
04DA:  BCF    03.6
04DB:  RETURN
*
07DB:  MOVF   6F,W
07DC:  CLRF   78
07DD:  SUBWF  6E,W
07DE:  BTFSC  03.0
07DF:  GOTO   7E3
07E0:  MOVF   6E,W
07E1:  MOVWF  77
07E2:  GOTO   7EF
07E3:  CLRF   77
07E4:  MOVLW  08
07E5:  MOVWF  70
07E6:  RLF    6E,F
07E7:  RLF    77,F
07E8:  MOVF   6F,W
07E9:  SUBWF  77,W
07EA:  BTFSC  03.0
07EB:  MOVWF  77
07EC:  RLF    78,F
07ED:  DECFSZ 70,F
07EE:  GOTO   7E6
07EF:  RETURN
*
0A92:  BTFSC  69.7
0A93:  GOTO   2A6
0A94:  MOVLW  0F
0A95:  MOVWF  77
0A96:  SWAPF  68,W
0A97:  ANDWF  77,F
0A98:  MOVLW  0A
0A99:  SUBWF  77,W
0A9A:  BTFSC  03.0
0A9B:  GOTO   29F
0A9C:  MOVLW  30
0A9D:  ADDWF  77,F
0A9E:  GOTO   2A1
0A9F:  MOVF   69,W
0AA0:  ADDWF  77,F
0AA1:  MOVF   77,W
0AA2:  MOVWF  6E
0AA3:  BCF    0A.3
0AA4:  CALL   273
0AA5:  BSF    0A.3
0AA6:  MOVLW  0F
0AA7:  ANDWF  68,F
0AA8:  MOVLW  0A
0AA9:  SUBWF  68,W
0AAA:  BTFSC  03.0
0AAB:  GOTO   2AE
0AAC:  MOVLW  30
0AAD:  GOTO   2B0
0AAE:  BCF    69.7
0AAF:  MOVF   69,W
0AB0:  ADDWF  68,F
0AB1:  MOVF   68,W
0AB2:  MOVWF  6E
0AB3:  BCF    0A.3
0AB4:  CALL   273
0AB5:  BSF    0A.3
0AB6:  RETURN
*
0AE9:  MOVF   0B,W
0AEA:  MOVWF  69
0AEB:  BCF    0B.7
0AEC:  BSF    03.5
0AED:  BSF    03.6
0AEE:  BSF    0C.7
0AEF:  BSF    0C.0
0AF0:  NOP
0AF1:  NOP
0AF2:  BCF    03.5
0AF3:  BCF    03.6
0AF4:  BTFSC  69.7
0AF5:  BSF    0B.7
0AF6:  BTFSC  03.0
0AF7:  GOTO   322
0AF8:  BSF    03.6
0AF9:  MOVF   0C,W
0AFA:  ANDLW  7F
0AFB:  BCF    03.6
0AFC:  MOVWF  69
0AFD:  BSF    03.6
0AFE:  MOVF   0D,W
0AFF:  BCF    03.6
0B00:  MOVWF  6A
0B01:  BSF    03.6
0B02:  MOVF   0F,W
0B03:  BCF    03.6
0B04:  MOVWF  6B
0B05:  MOVF   69,W
0B06:  MOVWF  6E
0B07:  BCF    0A.3
0B08:  CALL   273
0B09:  BSF    0A.3
0B0A:  MOVF   6A,W
0B0B:  BSF    03.6
0B0C:  MOVWF  0D
0B0D:  BCF    03.6
0B0E:  MOVF   6B,W
0B0F:  BSF    03.6
0B10:  MOVWF  0F
0B11:  BCF    03.6
0B12:  MOVF   0B,W
0B13:  MOVWF  6C
0B14:  BCF    0B.7
0B15:  BSF    03.5
0B16:  BSF    03.6
0B17:  BSF    0C.7
0B18:  BSF    0C.0
0B19:  NOP
0B1A:  NOP
0B1B:  BCF    03.5
0B1C:  BCF    03.6
0B1D:  BTFSC  6C.7
0B1E:  BSF    0B.7
0B1F:  DECFSZ 68,F
0B20:  GOTO   322
0B21:  GOTO   343
0B22:  BSF    03.6
0B23:  RLF    0C,W
0B24:  RLF    0E,W
0B25:  ANDLW  7F
0B26:  BCF    03.6
0B27:  MOVWF  69
0B28:  BSF    03.6
0B29:  MOVF   0D,W
0B2A:  BCF    03.6
0B2B:  MOVWF  6A
0B2C:  BSF    03.6
0B2D:  MOVF   0F,W
0B2E:  BCF    03.6
0B2F:  MOVWF  6B
0B30:  MOVF   69,W
0B31:  MOVWF  6E
0B32:  BCF    0A.3
0B33:  CALL   273
0B34:  BSF    0A.3
0B35:  MOVF   6A,W
0B36:  BSF    03.6
0B37:  MOVWF  0D
0B38:  BCF    03.6
0B39:  MOVF   6B,W
0B3A:  BSF    03.6
0B3B:  MOVWF  0F
0B3C:  INCF   0D,F
0B3D:  BTFSC  03.2
0B3E:  INCF   0F,F
0B3F:  BCF    03.0
0B40:  BCF    03.6
0B41:  DECFSZ 68,F
0B42:  GOTO   2E9
0B43:  RETURN
0B44:  MOVLW  20
0B45:  BTFSS  69.4
0B46:  MOVLW  30
0B47:  MOVWF  6A
0B48:  MOVF   68,W
0B49:  MOVWF  77
0B4A:  BTFSS  68.7
0B4B:  GOTO   354
0B4C:  COMF   77,F
0B4D:  INCF   77,F
0B4E:  MOVF   77,W
0B4F:  MOVWF  68
0B50:  MOVLW  2D
0B51:  MOVWF  6A
0B52:  BSF    69.7
0B53:  BSF    69.0
0B54:  MOVF   68,W
0B55:  MOVWF  6E
0B56:  MOVLW  64
0B57:  MOVWF  6F
0B58:  BCF    0A.3
0B59:  CALL   7DB
0B5A:  BSF    0A.3
0B5B:  MOVF   77,W
0B5C:  MOVWF  68
0B5D:  MOVLW  30
0B5E:  ADDWF  78,W
0B5F:  MOVWF  6B
0B60:  MOVF   68,W
0B61:  MOVWF  6E
0B62:  MOVLW  0A
0B63:  MOVWF  6F
0B64:  BCF    0A.3
0B65:  CALL   7DB
0B66:  BSF    0A.3
0B67:  MOVLW  30
0B68:  ADDWF  77,W
0B69:  MOVWF  6D
0B6A:  MOVLW  30
0B6B:  ADDWF  78,W
0B6C:  MOVWF  6C
0B6D:  MOVF   6A,W
0B6E:  MOVWF  77
0B6F:  MOVLW  30
0B70:  SUBWF  6B,W
0B71:  BTFSC  03.2
0B72:  GOTO   377
0B73:  BSF    69.1
0B74:  BTFSC  69.7
0B75:  BSF    69.2
0B76:  GOTO   38B
0B77:  MOVF   6A,W
0B78:  MOVWF  6B
0B79:  MOVLW  20
0B7A:  MOVWF  6A
0B7B:  MOVLW  30
0B7C:  SUBWF  6C,W
0B7D:  BTFSC  03.2
0B7E:  GOTO   383
0B7F:  BSF    69.0
0B80:  BTFSC  69.7
0B81:  BSF    69.1
0B82:  GOTO   38B
0B83:  BTFSS  03.2
0B84:  BSF    69.0
0B85:  BTFSS  03.2
0B86:  GOTO   38B
0B87:  MOVF   6B,W
0B88:  MOVWF  6C
0B89:  MOVLW  20
0B8A:  MOVWF  6B
0B8B:  BTFSC  69.2
0B8C:  GOTO   392
0B8D:  BTFSC  69.1
0B8E:  GOTO   397
0B8F:  BTFSC  69.0
0B90:  GOTO   39C
0B91:  GOTO   3A1
0B92:  MOVF   6A,W
0B93:  MOVWF  6E
0B94:  BCF    0A.3
0B95:  CALL   273
0B96:  BSF    0A.3
0B97:  MOVF   6B,W
0B98:  MOVWF  6E
0B99:  BCF    0A.3
0B9A:  CALL   273
0B9B:  BSF    0A.3
0B9C:  MOVF   6C,W
0B9D:  MOVWF  6E
0B9E:  BCF    0A.3
0B9F:  CALL   273
0BA0:  BSF    0A.3
0BA1:  MOVF   6D,W
0BA2:  MOVWF  6E
0BA3:  BCF    0A.3
0BA4:  CALL   273
0BA5:  BSF    0A.3
0BA6:  BCF    0A.3
0BA7:  BSF    0A.4
0BA8:  GOTO   522 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O
.................... 
.................... #define MFRC522_CS  PIN_E0                 
.................... #define MFRC522_SCK PIN_C3
.................... #define MFRC522_SI  PIN_C4                           
.................... #define MFRC522_SO  PIN_C5              
.................... #define MFRC522_RST PIN_E2
.................... 
.................... #use delay(crystal=20000000)
.................... #include <lcd.h>
.................... #define _lcd_h_
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+3);
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #use delay(clock=20000000)
*
0180:  MOVLW  6F
0181:  MOVWF  04
0182:  BCF    03.7
0183:  MOVF   00,W
0184:  BTFSC  03.2
0185:  GOTO   193
0186:  MOVLW  06
0187:  MOVWF  78
0188:  CLRF   77
0189:  DECFSZ 77,F
018A:  GOTO   189
018B:  DECFSZ 78,F
018C:  GOTO   188
018D:  MOVLW  7B
018E:  MOVWF  77
018F:  DECFSZ 77,F
0190:  GOTO   18F
0191:  DECFSZ 00,F
0192:  GOTO   186
0193:  RETURN
.................... void lcd_init(void);             // Ham dung de khoi dong C.LCD.
.................... byte lcd_read_byte(void);         // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... byte lcd_read_nibble(void);         // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
.................... void lcd_send_byte(byte address, byte n);   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... void lcd_send_nibble(byte n);      // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... void lcd_gotoxy(byte x, byte y);   // Ham thiet lap vi tri ghi tren C.LCD.
.................... char lcd_getc(byte x, byte y);      // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... void lcd_putc(char c);            // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... // Khai bao bien.
.................... // Dinh nghia cac thong so.
.................... #define LCD_RS_PIN         PIN_B7   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN         PIN_B6
.................... #define LCD_ENABLE_PIN     PIN_B5
.................... #define LCD_DATA4          PIN_B4
.................... #define LCD_DATA5          PIN_B3
.................... #define LCD_DATA6          PIN_B2
.................... #define LCD_DATA7          PIN_B1 
.................... /*
.................... #define LCD_RS_PIN            PIN_C5   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN         PIN_C6
.................... #define LCD_ENABLE_PIN     PIN_C7
.................... #define LCD_DATA4          PIN_D4
.................... #define LCD_DATA5          PIN_D5
.................... #define LCD_DATA6          PIN_D6
.................... #define LCD_DATA7          PIN_D7  
.................... */
.................... /*
.................... #define LCD_RS_PIN         PIN_D1   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN      PIN_D2
.................... #define LCD_ENABLE_PIN  PIN_D3
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7  
.................... */
.................... #define lcd_output_enable(x)   output_bit(LCD_ENABLE_PIN, x)   // Lenh dieu khien chan LCD_ENABLE_PIN.
.................... #define lcd_enable_tris()   output_drive(LCD_ENABLE_PIN)
.................... 
.................... #define lcd_output_rs(x)   output_bit(LCD_RS_PIN, x)   // Lenh dieu khien chan LCD_RS_PIN.
.................... #define lcd_rs_tris()      output_drive(LCD_RS_PIN)
.................... 
.................... #define lcd_output_rw(x)   output_bit(LCD_RW_PIN, x)   // Lenh dieu khien chan LCD_RW_PIN
.................... #define lcd_rw_tris()      output_drive(LCD_RW_PIN)
.................... 
.................... #define lcd_line_one   0x00    // Dia chi RAM C.LCD cho hang thu 1.
.................... #define lcd_line_two   0x40    // Dia chi RAM C.LCD cho hang thu 2.
.................... #define lcd_line_three   0x14
.................... #define lcd_line_four   0x54
.................... #define LCD_TYPE 0x02           // Thong tin cau hinh C.LCD: 0x00=5x7, 0x01=5x10, 0x02=2 lines
.................... 
.................... // Dinh nghia cac hang so.
.................... byte const LCD_INIT_STRING[4] = {0x28 | (LCD_TYPE << 2), 0x0C, 0x01, 0x06};
....................         // Cac byte nay can thiet de gui toi C.LCD, dung de khoi dong cau hinh hoat dong cho C.LCD.
....................       // Byte 1: 0x20 | (LCD_TYPE << 2) - So bit du lieu giao tiep (DL), so dong hien thi (N), kieu ky tu (F).
....................       //         0 0 1 DL N F x x (DL: Data Length, N: Number Line, F: Font).
....................          // Truong hop 1: 0x20 - 4 bit / 1 dong / 5 x 7.
....................          // Truong hop 2: 0x24 - 4 bit / 1 dong / 5 x 10.
....................          // Truong hop 3: 0x28 - 4 bit / 2 dong / 5 x 7.
....................       // Byte 2: 0x0C - Dieu khien hien thi (Bat hien thi, tat con tro, tat nhap nhay con tro).
....................       //         0 0 0 0 1 D C B (D: Display, C: Cursor, B: Blink).
....................       // Byte 3: 0x01 - Xoa hien thi va tra con tro ve dau dong.
....................       // Byte 4: 0x06 - Dat che do dau vao (Che do tang dia chi, tat dich chuyen hien thi).
....................       //         0 0 0 0 0 1 I/D S (I/D: Increment/Decrement, S: Shift).
....................       // Byte 5: .... - Doi con tro / hien thi.
....................       //         0 0 0 1 S/C R/L x x (S/C: Screen/Cursor, R/L: Right/Left).
.................... 
.................... // ***************************************************
.................... void lcd_init(void)    // Ham dung de khoi dong C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte i;
.................... // Dinh nghia ham.
.................... output_drive(LCD_DATA4);   // Thiet lap chan port (Data) o che do ngo ra.
*
0297:  BSF    03.5
0298:  BCF    06.4
.................... output_drive(LCD_DATA5);
0299:  BCF    06.3
.................... output_drive(LCD_DATA6);
029A:  BCF    06.2
.................... output_drive(LCD_DATA7);
029B:  BCF    06.1
.................... 
.................... lcd_enable_tris();         // Thiet lap chan port (Control: EN, RS, RW) o che do ngo ra.
029C:  BCF    06.5
.................... lcd_rs_tris();
029D:  BCF    06.7
.................... lcd_rw_tris();
029E:  BCF    06.6
.................... 
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
029F:  BCF    03.5
02A0:  BCF    06.7
02A1:  BSF    03.5
02A2:  BCF    06.7
.................... lcd_output_rw(0);         // RW = 0 - Ghi thong tin vao C.LCD.
02A3:  BCF    03.5
02A4:  BCF    06.6
02A5:  BSF    03.5
02A6:  BCF    06.6
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
02A7:  BCF    03.5
02A8:  BCF    06.5
02A9:  BSF    03.5
02AA:  BCF    06.5
.................... 
.................... delay_ms(15);   // Tao thoi gian tre 15ms (Thoi gian de LCD tu reset khi moi duoc cap nguon).
02AB:  MOVLW  0F
02AC:  BCF    03.5
02AD:  MOVWF  6F
02AE:  CALL   180
.................... 
.................... for(i=1;i<=3;i++)         // Doan lenh khoi dong C.LCD o che do 8 bit duoc thuc hien 3 lan lien tiep
02AF:  MOVLW  01
02B0:  MOVWF  67
02B1:  MOVF   67,W
02B2:  SUBLW  03
02B3:  BTFSS  03.0
02B4:  GOTO   2BD
....................    {                  // tai thoi diem ban dau (de dam bao cho C.LCD hoat dong on dinh trong 
....................    lcd_send_nibble(0x03);    // truong hop khi cung cap nguon cho C.LCD ma dien ap nguon tang len cham).
02B5:  MOVLW  03
02B6:  MOVWF  76
02B7:  CALL   194
....................    delay_ms(5);         // RS = 0, RW = 0, D7 - D4 = 0011 (0x03) -> DL = 1 (8 bit).
02B8:  MOVLW  05
02B9:  MOVWF  6F
02BA:  CALL   180
02BB:  INCF   67,F
02BC:  GOTO   2B1
....................    }                  // Do co BF (Busy Flag) chua kiem tra duoc trong thoi diem nay, nen phai 
....................                      // thuc hien 3 lan (xem luu do khoi dong C.LCD cua nha san xuat).
.................... 
.................... lcd_send_nibble(0x02);      // Doan lenh khoi dong C.LCD o che do 4 bit. Tu luc nay thi 4 bit cao duoc ghi
02BD:  MOVLW  02
02BE:  MOVWF  76
02BF:  CALL   194
....................                      // ra truoc tien, sau do la 4 bit thap.
....................                      // RS = 0, RW = 0, D7 - D4 = 0010 (0x02) -> DL = 0 (4 bit).
....................                      // Co BF (Busy Flag) co the bat dau kiem tra duoc tu luc nay.
.................... 
.................... for(i=0;i<=3;i++)
02C0:  CLRF   67
02C1:  MOVF   67,W
02C2:  SUBLW  03
02C3:  BTFSS  03.0
02C4:  GOTO   2CE
....................    lcd_send_byte(0,LCD_INIT_STRING[i]);   // Goi ham truyen thong tin (lenh) sang C.LCD.
02C5:  MOVF   67,W
02C6:  CALL   004
02C7:  MOVWF  68
02C8:  CLRF   73
02C9:  MOVF   68,W
02CA:  MOVWF  74
02CB:  CALL   1F9
02CC:  INCF   67,F
02CD:  GOTO   2C1
.................... }                                 // Lenh: Thiet lap cau hinh hoat dong cho C.LCD.
.................... 
.................... // ***************************************************
.................... byte lcd_read_byte(void)   // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte low,high;
.................... // Dinh nghia ham.
.................... output_float(LCD_DATA4);   // Thiet lap chan port o che do ngo vao.
*
01FC:  BSF    06.4
.................... output_float(LCD_DATA5);
01FD:  BSF    06.3
.................... output_float(LCD_DATA6);
01FE:  BSF    06.2
.................... output_float(LCD_DATA7);
01FF:  BSF    06.1
.................... 
.................... lcd_output_rw(1);         // RW = 1 - Doc thong tin tu C.LCD.
0200:  BCF    03.5
0201:  BSF    06.6
0202:  BSF    03.5
0203:  BCF    06.6
....................                   // Tien hanh doc 4 bit cao cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0204:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
0205:  BCF    03.5
0206:  BSF    06.5
0207:  BSF    03.5
0208:  BCF    06.5
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0209:  NOP
.................... high = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit cao).
020A:  BCF    03.5
020B:  CALL   1C8
020C:  MOVF   78,W
020D:  MOVWF  76
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
020E:  BCF    06.5
020F:  BSF    03.5
0210:  BCF    06.5
....................                   // Tien hanh doc 4 bit thap cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0211:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
0212:  BCF    03.5
0213:  BSF    06.5
0214:  BSF    03.5
0215:  BCF    06.5
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0216:  NOP
.................... low = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit thap).
0217:  BCF    03.5
0218:  CALL   1C8
0219:  MOVF   78,W
021A:  MOVWF  75
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
021B:  BCF    06.5
021C:  BSF    03.5
021D:  BCF    06.5
.................... 
.................... output_drive(LCD_DATA4);   // Thiet lap chan port o che do ngo ra.
021E:  BCF    06.4
.................... output_drive(LCD_DATA5);
021F:  BCF    06.3
.................... output_drive(LCD_DATA6);
0220:  BCF    06.2
.................... output_drive(LCD_DATA7);
0221:  BCF    06.1
.................... 
.................... return((high<<4) | low);   // Tra ve ket qua du lieu (dang 8 bit).
0222:  SWAPF  76,W
0223:  MOVWF  77
0224:  MOVLW  F0
0225:  ANDWF  77,F
0226:  MOVF   77,W
0227:  IORWF  75,W
0228:  MOVWF  78
.................... }
.................... 
.................... // ***************************************************
.................... byte lcd_read_nibble(void)   // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
*
01C8:  CLRF   7B
.................... {
.................... // Khai bao bien.
.................... byte n = 0x00;   // Mac dinh gia tri ban dau cho noi chua se thong tin.
.................... // Dinh nghia ham.
.................... n |= input(LCD_DATA4);         // Doc lan luot cac bit tu bus du lieu.
01C9:  BSF    03.5
01CA:  BSF    06.4
01CB:  MOVLW  00
01CC:  BCF    03.5
01CD:  BTFSC  06.4
01CE:  MOVLW  01
01CF:  IORWF  7B,F
.................... n |= input(LCD_DATA5) << 1;
01D0:  BSF    03.5
01D1:  BSF    06.3
01D2:  MOVLW  00
01D3:  BCF    03.5
01D4:  BTFSC  06.3
01D5:  MOVLW  01
01D6:  MOVWF  77
01D7:  BCF    03.0
01D8:  RLF    77,F
01D9:  MOVF   77,W
01DA:  IORWF  7B,F
.................... n |= input(LCD_DATA6) << 2;
01DB:  BSF    03.5
01DC:  BSF    06.2
01DD:  MOVLW  00
01DE:  BCF    03.5
01DF:  BTFSC  06.2
01E0:  MOVLW  01
01E1:  MOVWF  77
01E2:  RLF    77,F
01E3:  RLF    77,F
01E4:  MOVLW  FC
01E5:  ANDWF  77,F
01E6:  MOVF   77,W
01E7:  IORWF  7B,F
.................... n |= input(LCD_DATA7) << 3;
01E8:  BSF    03.5
01E9:  BSF    06.1
01EA:  MOVLW  00
01EB:  BCF    03.5
01EC:  BTFSC  06.1
01ED:  MOVLW  01
01EE:  MOVWF  77
01EF:  RLF    77,F
01F0:  RLF    77,F
01F1:  RLF    77,F
01F2:  MOVLW  F8
01F3:  ANDWF  77,F
01F4:  MOVF   77,W
01F5:  IORWF  7B,F
.................... 
.................... return(n);   // Tra ve ket qua doc duoc (data = 0000 xxxx).
01F6:  MOVF   7B,W
01F7:  MOVWF  78
01F8:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_byte(byte address, byte n)   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... {                                 // address = 0: Lenh / 1: Du lieu.
....................                                  // byte = Thong tin can gui (8 bit).
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham.  
.................... lcd_output_rs(0);      // RS = 0 - Databus = Bus lenh.
01F9:  BCF    06.7
01FA:  BSF    03.5
01FB:  BCF    06.7
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
*
0229:  MOVF   78,W
022A:  MOVWF  75
022B:  BTFSC  75.7
022C:  GOTO   1FC
.................... lcd_output_rs(address);   // RS = address - Databus = Bus lenh/du lieu.
022D:  MOVF   73,F
022E:  BTFSS  03.2
022F:  GOTO   234
0230:  BCF    03.5
0231:  BCF    06.7
0232:  GOTO   236
0233:  BSF    03.5
0234:  BCF    03.5
0235:  BSF    06.7
0236:  BSF    03.5
0237:  BCF    06.7
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
0238:  NOP
.................... lcd_output_rw(0);      // RW = 0 - Ghi thong tin vao C.LCD.
0239:  BCF    03.5
023A:  BCF    06.6
023B:  BSF    03.5
023C:  BCF    06.6
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
023D:  NOP
.................... lcd_output_enable(0);   // EN = 0 - Cam truy xuat C.LCD.
023E:  BCF    03.5
023F:  BCF    06.5
0240:  BSF    03.5
0241:  BCF    06.5
.................... lcd_send_nibble(n >> 4);   // Goi ham truyen 4 bit cao sang C.LCD.
0242:  SWAPF  74,W
0243:  MOVWF  75
0244:  MOVLW  0F
0245:  ANDWF  75,F
0246:  MOVF   75,W
0247:  MOVWF  76
0248:  BCF    03.5
0249:  CALL   194
.................... lcd_send_nibble(n & 0x0F);   // Goi ham truyen 4 bit thap sang C.LCD.
024A:  MOVF   74,W
024B:  ANDLW  0F
024C:  MOVWF  75
024D:  MOVWF  76
024E:  CALL   194
024F:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_nibble(byte n)   // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... {                        // n = Thong tin can gui. 4 bit can gui phai nam vi tri 4 bit thap.
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... output_bit(LCD_DATA4, bit_test(n, 0));   // Xuat lan luot cac bit len bus du lieu.
*
0194:  BTFSC  76.0
0195:  GOTO   198
0196:  BCF    06.4
0197:  GOTO   199
0198:  BSF    06.4
0199:  BSF    03.5
019A:  BCF    06.4
.................... output_bit(LCD_DATA5, bit_test(n, 1));
019B:  BTFSC  76.1
019C:  GOTO   1A1
019D:  BCF    03.5
019E:  BCF    06.3
019F:  GOTO   1A3
01A0:  BSF    03.5
01A1:  BCF    03.5
01A2:  BSF    06.3
01A3:  BSF    03.5
01A4:  BCF    06.3
.................... output_bit(LCD_DATA6, bit_test(n, 2));
01A5:  BTFSC  76.2
01A6:  GOTO   1AB
01A7:  BCF    03.5
01A8:  BCF    06.2
01A9:  GOTO   1AD
01AA:  BSF    03.5
01AB:  BCF    03.5
01AC:  BSF    06.2
01AD:  BSF    03.5
01AE:  BCF    06.2
.................... output_bit(LCD_DATA7, bit_test(n, 3));
01AF:  BTFSC  76.3
01B0:  GOTO   1B5
01B1:  BCF    03.5
01B2:  BCF    06.1
01B3:  GOTO   1B7
01B4:  BSF    03.5
01B5:  BCF    03.5
01B6:  BSF    06.1
01B7:  BSF    03.5
01B8:  BCF    06.1
....................     
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
01B9:  NOP
.................... lcd_output_enable(1);   // Tao xung ghi thong tin vao C.LCD.
01BA:  BCF    03.5
01BB:  BSF    06.5
01BC:  BSF    03.5
01BD:  BCF    06.5
.................... delay_us(2);         // Tao tre 2 chu ky (t=2us voi fosc=4MHz).
01BE:  MOVLW  03
01BF:  MOVWF  77
01C0:  DECFSZ 77,F
01C1:  GOTO   1C0
.................... lcd_output_enable(0);   // Tao xung ghi thong tin vao LCD - EN = 1->0 (High to Low).
01C2:  BCF    03.5
01C3:  BCF    06.5
01C4:  BSF    03.5
01C5:  BCF    06.5
01C6:  BCF    03.5
01C7:  RETURN
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_gotoxy(byte x, byte y)   // Ham thiet lap vi tri ghi tren C.LCD (Goc tren ben trai co toa do la 1,1).
.................... {
.................... // Khai bao bien.
.................... byte address;
.................... // Dinh nghia ham.  
.................... if(y==1)               // Kiem tra vi tri truy xuat thuoc hang 2.
*
0250:  DECFSZ 70,W
0251:  GOTO   254
....................    address=lcd_line_one;      // Nap dia chi RAM cua hang 2. 
0252:  CLRF   71
0253:  GOTO   268
.................... else if(y==2)      // Neu vi tri truy xuat thuoc hang 1.
0254:  MOVF   70,W
0255:  SUBLW  02
0256:  BTFSS  03.2
0257:  GOTO   25B
....................    address=lcd_line_two;      // Nap dia chi RAM cua hang 1.
0258:  MOVLW  40
0259:  MOVWF  71
025A:  GOTO   268
.................... else if(y==3)
025B:  MOVF   70,W
025C:  SUBLW  03
025D:  BTFSS  03.2
025E:  GOTO   262
....................    address=lcd_line_three;     
025F:  MOVLW  14
0260:  MOVWF  71
0261:  GOTO   268
.................... else if(y==4)
0262:  MOVF   70,W
0263:  SUBLW  04
0264:  BTFSS  03.2
0265:  GOTO   268
....................    address=lcd_line_four;   
0266:  MOVLW  54
0267:  MOVWF  71
.................... 
.................... address+=x-1;               // Ghep dia chi cot vao dia chi tong quat (address). address = address + (x-1).      
0268:  MOVLW  01
0269:  SUBWF  6F,W
026A:  ADDWF  71,F
....................                         // Ta qui uoc: Goc tren ben trai co toa do la 1,1 -> Cot dau tien la Cot 1
....................                         // (x-1) vi C.LCD qui uoc cot dau tien co dia chi la 0.
.................... lcd_send_byte(0,0x80|address);   // Goi ham truyen thong tin (lenh) sang C.LCD.
026B:  MOVF   71,W
026C:  IORLW  80
026D:  MOVWF  72
026E:  CLRF   73
026F:  MOVF   72,W
0270:  MOVWF  74
0271:  CALL   1F9
0272:  RETURN
.................... }                        // Lenh: Thiet lap dia chi DDRAM cua C.LCD (addresss).   
.................... 
.................... // ***************************************************
.................... char lcd_getc(byte x, byte y)   // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... char value;
.................... // Dinh nghia ham.  
.................... lcd_gotoxy(x,y);            // Xac dinh toa do C.LCD can truy xuat.
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
.................... lcd_output_rs(1);         // RS = 1 - Databus = Bus du lieu.
.................... value = lcd_read_byte();   // Doc ve tu C.LCD.
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
.................... 
.................... return(value);      // Tra ve ma ky tu tai toa do yeu cau.
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_putc(char c)   // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... switch (c)
0273:  MOVF   6E,W
0274:  XORLW  0C
0275:  BTFSC  03.2
0276:  GOTO   27E
0277:  XORLW  06
0278:  BTFSC  03.2
0279:  GOTO   286
027A:  XORLW  02
027B:  BTFSC  03.2
027C:  GOTO   28C
027D:  GOTO   291
....................    {
....................    case '\f':     // Chuc nang xoa hien thi.
....................       lcd_send_byte(0,0x01);   // Goi ham truyen thong tin (lenh) sang C.LCD.
027E:  CLRF   73
027F:  MOVLW  01
0280:  MOVWF  74
0281:  CALL   1F9
....................       delay_ms(2);         // Lenh: Xoa hien thi tren man hinh C.LCD (0x01).
0282:  MOVLW  02
0283:  MOVWF  6F
0284:  CALL   180
....................       break;
0285:  GOTO   296
....................    case '\n':       // Chuc nang bat dau hang thu 2.
....................       lcd_gotoxy(1,0x02);     // Goi ham truyen thong tin (du lieu) sang C.LCD.   
0286:  MOVLW  01
0287:  MOVWF  6F
0288:  MOVLW  02
0289:  MOVWF  70
028A:  CALL   250
....................       break;
028B:  GOTO   296
....................     case '\b':       // Chuc nang lui ve 1 vi tri.
....................       lcd_send_byte(0,0x10);    // Goi ham truyen thong tin (lenh) sang C.LCD. 
028C:  CLRF   73
028D:  MOVLW  10
028E:  MOVWF  74
028F:  CALL   1F9
....................       break;               // Lenh: Doi con tro sang trai (0x10).
0290:  GOTO   296
....................    default:       // Chuc nang hien thi ky tu c tai vi tri ke tiep tren C.LCD.
....................       lcd_send_byte(1,c);     // Goi ham truyen thong tin (du lieu) sang C.LCD.
0291:  MOVLW  01
0292:  MOVWF  73
0293:  MOVF   6E,W
0294:  MOVWF  74
0295:  CALL   1F9
....................       break;
....................    }
0296:  RETURN
.................... }      
.................... // ***************************************************   
.................... 
.................... #include <Keypad.h>
.................... #define _Keypad_h_
.................... #include <math.h>//chen thu vien toan
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+3);
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #use delay(clock=20000000)
*
0573:  MOVLW  6A
0574:  MOVWF  04
0575:  BCF    03.7
0576:  MOVF   00,W
0577:  BTFSC  03.2
0578:  GOTO   586
0579:  MOVLW  06
057A:  MOVWF  78
057B:  CLRF   77
057C:  DECFSZ 77,F
057D:  GOTO   57C
057E:  DECFSZ 78,F
057F:  GOTO   57B
0580:  MOVLW  7B
0581:  MOVWF  77
0582:  DECFSZ 77,F
0583:  GOTO   582
0584:  DECFSZ 00,F
0585:  GOTO   579
0586:  RETURN
.................... 
.................... void control(char TenCot, int1 TrangThai);
.................... void keypad_init(void);
.................... char scan(void);
.................... //khai bao ket noi cac cot
.................... #define COT_1     PIN_D0
.................... #define COT_2     PIN_D1
.................... #define COT_3     PIN_D2
.................... #define COT_4     PIN_D3
.................... 
.................... //khai bao ket noi cac hang
.................... #define HANG_1    input(PIN_D4) 
.................... #define HANG_2    input(PIN_D5)
.................... #define HANG_3    input(PIN_D6)
.................... #define HANG_4    input(PIN_D7)
.................... 
.................... char PhimNhan[16]=
....................                {
....................                   'D','C','B','A', 
....................                   '#','9','6','3',
....................                   '0','8','5','2',
....................                   '*','7','4','1'
....................                };
*
1019:  MOVLW  44
101A:  BCF    03.6
101B:  MOVWF  20
101C:  MOVLW  43
101D:  MOVWF  21
101E:  MOVLW  42
101F:  MOVWF  22
1020:  MOVLW  41
1021:  MOVWF  23
1022:  MOVLW  23
1023:  MOVWF  24
1024:  MOVLW  39
1025:  MOVWF  25
1026:  MOVLW  36
1027:  MOVWF  26
1028:  MOVLW  33
1029:  MOVWF  27
102A:  MOVLW  30
102B:  MOVWF  28
102C:  MOVLW  38
102D:  MOVWF  29
102E:  MOVLW  35
102F:  MOVWF  2A
1030:  MOVLW  32
1031:  MOVWF  2B
1032:  MOVLW  2A
1033:  MOVWF  2C
1034:  MOVLW  37
1035:  MOVWF  2D
1036:  MOVLW  34
1037:  MOVWF  2E
1038:  MOVLW  31
1039:  MOVWF  2F
....................                
.................... 
.................... void control(char TenCot, int1 TrangThai)
.................... {
....................    switch(TenCot)
*
0425:  MOVLW  01
0426:  SUBWF  69,W
0427:  ADDLW  FC
0428:  BTFSC  03.0
0429:  GOTO   453
042A:  ADDLW  04
042B:  GOTO   454
....................    {
....................       case 1://cot 1
....................       {
....................          output_bit(COT_1,TrangThai);
042C:  MOVF   6A,F
042D:  BTFSS  03.2
042E:  GOTO   431
042F:  BCF    08.0
0430:  GOTO   432
0431:  BSF    08.0
0432:  BSF    03.5
0433:  BCF    08.0
....................          break;
0434:  BCF    03.5
0435:  GOTO   453
....................       }
....................       case 2://cot 2
....................       {
....................          output_bit(COT_2,TrangThai);
0436:  MOVF   6A,F
0437:  BTFSS  03.2
0438:  GOTO   43B
0439:  BCF    08.1
043A:  GOTO   43C
043B:  BSF    08.1
043C:  BSF    03.5
043D:  BCF    08.1
....................          break;
043E:  BCF    03.5
043F:  GOTO   453
....................       }
....................       case 3://cot 3
....................       {
....................          output_bit(COT_3,TrangThai);
0440:  MOVF   6A,F
0441:  BTFSS  03.2
0442:  GOTO   445
0443:  BCF    08.2
0444:  GOTO   446
0445:  BSF    08.2
0446:  BSF    03.5
0447:  BCF    08.2
....................          break;
0448:  BCF    03.5
0449:  GOTO   453
....................       }
....................       case 4://cot 4
....................       {
....................          output_bit(COT_4,TrangThai);
044A:  MOVF   6A,F
044B:  BTFSS  03.2
044C:  GOTO   44F
044D:  BCF    08.3
044E:  GOTO   450
044F:  BSF    08.3
0450:  BSF    03.5
0451:  BCF    08.3
....................          break;
0452:  BCF    03.5
....................       }      
....................    }
0453:  RETURN
.................... }
.................... 
.................... void keypad_init(void)
.................... {
....................    char i;
....................    
....................    for(i=1;i<=4;i++)
*
045C:  MOVLW  01
045D:  MOVWF  67
045E:  MOVF   67,W
045F:  SUBLW  04
0460:  BTFSS  03.0
0461:  GOTO   468
....................    {
....................       control(i,0);//bat het cac cot len
0462:  MOVF   67,W
0463:  MOVWF  69
0464:  CLRF   6A
0465:  CALL   425
0466:  INCF   67,F
0467:  GOTO   45E
....................    }
0468:  BCF    0A.3
0469:  BSF    0A.4
046A:  GOTO   042 (RETURN)
.................... }
.................... 
.................... char scan(void)
*
04DC:  CLRF   68
.................... {
....................    char Key=0;
....................    
....................    //quet cot 1
....................    control(1,1);//tat cot 1 di
04DD:  MOVLW  01
04DE:  MOVWF  69
04DF:  MOVWF  6A
04E0:  CALL   425
....................    if(HANG_1==1)
04E1:  BSF    03.5
04E2:  BSF    08.4
04E3:  BCF    03.5
04E4:  BTFSS  08.4
04E5:  GOTO   4E8
....................    {
....................       Key=1;
04E6:  MOVLW  01
04E7:  MOVWF  68
....................    }
....................    if(HANG_2==1)
04E8:  BSF    03.5
04E9:  BSF    08.5
04EA:  BCF    03.5
04EB:  BTFSS  08.5
04EC:  GOTO   4EF
....................    {
....................       Key=2;
04ED:  MOVLW  02
04EE:  MOVWF  68
....................    }
....................    if(HANG_3==1)
04EF:  BSF    03.5
04F0:  BSF    08.6
04F1:  BCF    03.5
04F2:  BTFSS  08.6
04F3:  GOTO   4F6
....................    {
....................       Key=3;
04F4:  MOVLW  03
04F5:  MOVWF  68
....................    }
....................    if(HANG_4==1)
04F6:  BSF    03.5
04F7:  BSF    08.7
04F8:  BCF    03.5
04F9:  BTFSS  08.7
04FA:  GOTO   4FD
....................    {
....................       Key=4;
04FB:  MOVLW  04
04FC:  MOVWF  68
....................    }   
....................    control(1,0);//bat cot 1 len
04FD:  MOVLW  01
04FE:  MOVWF  69
04FF:  CLRF   6A
0500:  CALL   425
....................    
....................    //quet cot 2
....................    control(2,1);//tat cot 2 di
0501:  MOVLW  02
0502:  MOVWF  69
0503:  MOVLW  01
0504:  MOVWF  6A
0505:  CALL   425
....................    if(HANG_1==1)
0506:  BSF    03.5
0507:  BSF    08.4
0508:  BCF    03.5
0509:  BTFSS  08.4
050A:  GOTO   50D
....................    {
....................       Key=5;
050B:  MOVLW  05
050C:  MOVWF  68
....................    }
....................    if(HANG_2==1)
050D:  BSF    03.5
050E:  BSF    08.5
050F:  BCF    03.5
0510:  BTFSS  08.5
0511:  GOTO   514
....................    {
....................       Key=6;
0512:  MOVLW  06
0513:  MOVWF  68
....................    }
....................    if(HANG_3==1)
0514:  BSF    03.5
0515:  BSF    08.6
0516:  BCF    03.5
0517:  BTFSS  08.6
0518:  GOTO   51B
....................    {
....................       Key=7;
0519:  MOVLW  07
051A:  MOVWF  68
....................    }
....................    if(HANG_4==1)
051B:  BSF    03.5
051C:  BSF    08.7
051D:  BCF    03.5
051E:  BTFSS  08.7
051F:  GOTO   522
....................    {
....................       Key=8;
0520:  MOVLW  08
0521:  MOVWF  68
....................    }   
....................    control(2,0);//bat cot 2 len
0522:  MOVLW  02
0523:  MOVWF  69
0524:  CLRF   6A
0525:  CALL   425
....................    
....................    //quet cot 3
....................    control(3,1);//tat cot 3 di
0526:  MOVLW  03
0527:  MOVWF  69
0528:  MOVLW  01
0529:  MOVWF  6A
052A:  CALL   425
....................    if(HANG_1==1)
052B:  BSF    03.5
052C:  BSF    08.4
052D:  BCF    03.5
052E:  BTFSS  08.4
052F:  GOTO   532
....................    {
....................       Key=9;
0530:  MOVLW  09
0531:  MOVWF  68
....................    }
....................    if(HANG_2==1)
0532:  BSF    03.5
0533:  BSF    08.5
0534:  BCF    03.5
0535:  BTFSS  08.5
0536:  GOTO   539
....................    {
....................       Key=10;
0537:  MOVLW  0A
0538:  MOVWF  68
....................    }
....................    if(HANG_3==1)
0539:  BSF    03.5
053A:  BSF    08.6
053B:  BCF    03.5
053C:  BTFSS  08.6
053D:  GOTO   540
....................    {
....................       Key=11;
053E:  MOVLW  0B
053F:  MOVWF  68
....................    }
....................    if(HANG_4==1)
0540:  BSF    03.5
0541:  BSF    08.7
0542:  BCF    03.5
0543:  BTFSS  08.7
0544:  GOTO   547
....................    {
....................       Key=12;
0545:  MOVLW  0C
0546:  MOVWF  68
....................    }   
....................    control(3,0);//bat cot 3 len
0547:  MOVLW  03
0548:  MOVWF  69
0549:  CLRF   6A
054A:  CALL   425
....................    
....................    //quet cot 4
....................    control(4,1);//tat cot 4 di
054B:  MOVLW  04
054C:  MOVWF  69
054D:  MOVLW  01
054E:  MOVWF  6A
054F:  CALL   425
....................    if(HANG_1==1)
0550:  BSF    03.5
0551:  BSF    08.4
0552:  BCF    03.5
0553:  BTFSS  08.4
0554:  GOTO   557
....................    {
....................       Key=13;
0555:  MOVLW  0D
0556:  MOVWF  68
....................    }
....................    if(HANG_2==1)
0557:  BSF    03.5
0558:  BSF    08.5
0559:  BCF    03.5
055A:  BTFSS  08.5
055B:  GOTO   55E
....................    {
....................       Key=14;
055C:  MOVLW  0E
055D:  MOVWF  68
....................    }
....................    if(HANG_3==1)
055E:  BSF    03.5
055F:  BSF    08.6
0560:  BCF    03.5
0561:  BTFSS  08.6
0562:  GOTO   565
....................    {
....................       Key=15;
0563:  MOVLW  0F
0564:  MOVWF  68
....................    }
....................    if(HANG_4==1)
0565:  BSF    03.5
0566:  BSF    08.7
0567:  BCF    03.5
0568:  BTFSS  08.7
0569:  GOTO   56C
....................    {
....................       Key=16;
056A:  MOVLW  10
056B:  MOVWF  68
....................    }   
....................    control(4,0);//bat cot 4 len
056C:  MOVLW  04
056D:  MOVWF  69
056E:  CLRF   6A
056F:  CALL   425
....................    
....................    return Key;//tra gia tri phim ve cho ham quet phim
0570:  MOVF   68,W
0571:  MOVWF  78
0572:  RETURN
.................... }
.................... 
.................... 
.................... #include <Built_in.h>
.................... //#use spi(FORCE_HW,master,baud = 10000000, BITS=8,MSB_FIRST, stream = RFID, ENABLE_ACTIVE=0)// uses hardware SPI and gives this stream the name SPI_STREAM
.................... //MF522 Command word
.................... #define PCD_IDLE              0x00               //NO action; Cancel the current command
.................... #define PCD_AUTHENT           0x0E               //Authentication Key
.................... #define PCD_RECEIVE           0x08               //Receive Data
.................... #define PCD_TRANSMIT          0x04               //Transmit data
.................... #define PCD_TRANSCEIVE        0x0C               //Transmit and receive data,
.................... #define PCD_RESETPHASE        0x0F               //Reset
.................... #define PCD_CALCCRC           0x03               //CRC Calculate
.................... // Mifare_One card command word                 
.................... #define PICC_REQIDL          0x26               // find the antenna area does not enter hibernation
.................... #define PICC_REQALL          0x52               // find all the cards antenna area
.................... #define PICC_ANTICOLL        0x93               // anti-collision
.................... #define PICC_SElECTTAG       0x93               // election card
.................... #define PICC_AUTHENT1A       0x60               // authentication key A
.................... #define PICC_AUTHENT1B       0x61               // authentication key B
.................... #define PICC_READ            0x30               // Read Block
.................... #define PICC_WRITE           0xA0               // write block
.................... #define PICC_DECREMENT       0xC0               // debit
.................... #define PICC_INCREMENT       0xC1               // recharge
.................... #define PICC_RESTORE         0xC2               // transfer block data to the buffer
.................... #define PICC_TRANSFER        0xB0               // save the data in the buffer
.................... #define PICC_HALT            0x50               // Sleep
.................... //And MF522 The error code is returned when communication
.................... #define MI_OK                 0
.................... #define MI_NOTAGERR           1
.................... #define MI_ERR                2
.................... //------------------MFRC522 Register---------------
.................... //Page 0:Command and Status
.................... #define     RESERVED00            0x00    
.................... #define     COMMANDREG            0x01    
.................... #define     COMMIENREG            0x02    
.................... #define     DIVLENREG             0x03    
.................... #define     COMMIRQREG            0x04    
.................... #define     DIVIRQREG             0x05
.................... #define     ERRORREG              0x06    
.................... #define     STATUS1REG            0x07    
.................... #define     STATUS2REG            0x08    
.................... #define     FIFODATAREG           0x09
.................... #define     FIFOLEVELREG          0x0A
.................... #define     WATERLEVELREG         0x0B
.................... #define     CONTROLREG            0x0C
.................... #define     BITFRAMINGREG         0x0D
.................... #define     COLLREG               0x0E
.................... #define     RESERVED01            0x0F
.................... //PAGE 1:Command     
.................... #define     RESERVED10            0x10
.................... #define     MODEREG               0x11
.................... #define     TXMODEREG             0x12
.................... #define     RXMODEREG             0x13
.................... #define     TXCONTROLREG          0x14
.................... #define     TXAUTOREG             0x15
.................... #define     TXSELREG              0x16
.................... #define     RXSELREG              0x17
.................... #define     RXTHRESHOLDREG        0x18
.................... #define     DEMODREG              0x19
.................... #define     RESERVED11            0x1A
.................... #define     RESERVED12            0x1B
.................... #define     MIFAREREG             0x1C
.................... #define     RESERVED13            0x1D
.................... #define     RESERVED14            0x1E
.................... #define     SERIALSPEEDREG        0x1F
.................... //PAGE 2:CFG    
.................... #define     RESERVED20            0x20  
.................... #define     CRCRESULTREGM         0x21
.................... #define     CRCRESULTREGL         0x22
.................... #define     RESERVED21            0x23
.................... #define     MODWIDTHREG           0x24
.................... #define     RESERVED22            0x25
.................... #define     RFCFGREG              0x26
.................... #define     GSNREG                0x27
.................... #define     CWGSPREG              0x28
.................... #define     MODGSPREG             0x29
.................... #define     TMODEREG              0x2A
.................... #define     TPRESCALERREG         0x2B
.................... #define     TRELOADREGH           0x2C
.................... #define     TRELOADREGL           0x2D
.................... #define     TCOUNTERVALUEREGH     0x2E
.................... #define     TCOUNTERVALUEREGL     0x2F
.................... //PAGE 3:TEST REGISTER     
.................... #define     RESERVED30            0x30
.................... #define     TESTSEL1REG           0x31
.................... #define     TESTSEL2REG           0x32
.................... #define     TESTPINENREG          0x33
.................... #define     TESTPINVALUEREG       0x34
.................... #define     TESTBUSREG            0x35
.................... #define     AUTOTESTREG           0x36
.................... #define     VERSIONREG            0x37
.................... #define     ANALOGTESTREG         0x38
.................... #define     TESTDAC1REG           0x39  
.................... #define     TESTDAC2REG           0x3A   
.................... #define     TESTADCREG            0x3B   
.................... #define     RESERVED31            0x3C   
.................... #define     RESERVED32            0x3D   
.................... #define     RESERVED33            0x3E   
.................... #define     RESERVED34            0x3F
.................... static void MFRC522_Wr_Old( char addr, char value )
.................... {
....................         output_bit(MFRC522_CS,0);              
....................         spi_write( ( addr << 1 ) & 0x7E );
....................         spi_write( value );
....................         output_bit(MFRC522_CS,1);
.................... }
.................... static char MFRC522_Rd_Old( char addr )
.................... {
.................... char value;
....................         output_bit(MFRC522_CS,0);                
....................         spi_write( (( addr << 1 ) & 0x7E)|0x80 );
....................         value = spi_read( 0x00 );                            
....................         output_bit(MFRC522_CS,1);     
....................         return value;
.................... } 
.................... 
.................... unsigned int8 MFRC522_Rd(unsigned int8 Address)  
*
0335:  BSF    03.5
0336:  CLRF   34
.................... {
....................    unsigned int i, ucAddr;
....................    unsigned int ucResult = 0;
....................    output_bit (MFRC522_SCK, 0);
0337:  BCF    03.5
0338:  BCF    07.3
0339:  BCF    30.3
033A:  MOVF   30,W
033B:  BSF    03.5
033C:  MOVWF  07
....................    output_bit (MFRC522_CS, 0);
033D:  BCF    03.5
033E:  BCF    09.0
033F:  BSF    03.5
0340:  BCF    09.0
....................    ucAddr = ( (Address<<1)&0x7E)|0x80;
0341:  BCF    03.0
0342:  RLF    31,W
0343:  ANDLW  7E
0344:  IORLW  80
0345:  MOVWF  33
....................    //Write spi
....................    FOR (i = 8; i > 0; i--)
0346:  MOVLW  08
0347:  MOVWF  32
0348:  MOVF   32,F
0349:  BTFSC  03.2
034A:  GOTO   36A
....................    {
....................       output_bit (MFRC522_SI, ((ucAddr&0x80) == 0x80));
034B:  MOVF   33,W
034C:  ANDLW  80
034D:  SUBLW  80
034E:  BTFSC  03.2
034F:  GOTO   354
0350:  BCF    03.5
0351:  BCF    07.4
0352:  GOTO   356
0353:  BSF    03.5
0354:  BCF    03.5
0355:  BSF    07.4
0356:  BCF    30.4
0357:  MOVF   30,W
0358:  BSF    03.5
0359:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
035A:  BCF    03.5
035B:  BSF    07.3
035C:  BCF    30.3
035D:  MOVF   30,W
035E:  BSF    03.5
035F:  MOVWF  07
....................       ucAddr <<= 1;
0360:  BCF    03.0
0361:  RLF    33,F
....................       output_bit (MFRC522_SCK, 0);
0362:  BCF    03.5
0363:  BCF    07.3
0364:  BCF    30.3
0365:  MOVF   30,W
0366:  BSF    03.5
0367:  MOVWF  07
0368:  DECF   32,F
0369:  GOTO   348
....................    }
.................... //SPI read
....................    FOR (i = 8; i > 0; i--)
036A:  MOVLW  08
036B:  MOVWF  32
036C:  MOVF   32,F
036D:  BTFSC  03.2
036E:  GOTO   38A
....................    {
....................       output_bit (MFRC522_SCK, 1);
036F:  BCF    03.5
0370:  BSF    07.3
0371:  BCF    30.3
0372:  MOVF   30,W
0373:  BSF    03.5
0374:  MOVWF  07
....................       ucResult <<= 1;
0375:  BCF    03.0
0376:  RLF    34,F
....................       ucResult|= (INT1) input (MFRC522_SO);
0377:  BCF    03.5
0378:  BSF    30.5
0379:  MOVF   30,W
037A:  BSF    03.5
037B:  MOVWF  07
037C:  MOVLW  00
037D:  BCF    03.5
037E:  BTFSC  07.5
037F:  MOVLW  01
0380:  BSF    03.5
0381:  IORWF  34,F
....................       output_bit (MFRC522_SCK, 0);
0382:  BCF    03.5
0383:  BCF    07.3
0384:  BCF    30.3
0385:  MOVF   30,W
0386:  BSF    03.5
0387:  MOVWF  07
0388:  DECF   32,F
0389:  GOTO   36C
....................    }
.................... 
....................    
....................    output_bit (MFRC522_CS, 1);
038A:  BCF    03.5
038B:  BSF    09.0
038C:  BSF    03.5
038D:  BCF    09.0
....................    output_bit (MFRC522_SCK, 1);
038E:  BCF    03.5
038F:  BSF    07.3
0390:  BCF    30.3
0391:  MOVF   30,W
0392:  BSF    03.5
0393:  MOVWF  07
....................    RETURN ucResult;
0394:  MOVF   34,W
0395:  MOVWF  78
0396:  BCF    03.5
0397:  RETURN
.................... }
.................... 
.................... void MFRC522_Wr(unsigned int8 Address, unsigned int8 value)
.................... {
....................    
....................    unsigned int8 i, ucAddr;
....................    output_bit (MFRC522_SCK, 0);
*
02D4:  BCF    07.3
02D5:  BCF    30.3
02D6:  MOVF   30,W
02D7:  BSF    03.5
02D8:  MOVWF  07
....................    output_bit (MFRC522_CS, 0);
02D9:  BCF    03.5
02DA:  BCF    09.0
02DB:  BSF    03.5
02DC:  BCF    09.0
....................    ucAddr = ( (Address<<1)&0x7E);
02DD:  BCF    03.0
02DE:  RLF    32,W
02DF:  ANDLW  7E
02E0:  MOVWF  35
....................    FOR (i = 8; i > 0; i--)
02E1:  MOVLW  08
02E2:  MOVWF  34
02E3:  MOVF   34,F
02E4:  BTFSC  03.2
02E5:  GOTO   305
....................    {
....................       output_bit (MFRC522_SI, ( (ucAddr&0x80) == 0x80));
02E6:  MOVF   35,W
02E7:  ANDLW  80
02E8:  SUBLW  80
02E9:  BTFSC  03.2
02EA:  GOTO   2EF
02EB:  BCF    03.5
02EC:  BCF    07.4
02ED:  GOTO   2F1
02EE:  BSF    03.5
02EF:  BCF    03.5
02F0:  BSF    07.4
02F1:  BCF    30.4
02F2:  MOVF   30,W
02F3:  BSF    03.5
02F4:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
02F5:  BCF    03.5
02F6:  BSF    07.3
02F7:  BCF    30.3
02F8:  MOVF   30,W
02F9:  BSF    03.5
02FA:  MOVWF  07
....................       ucAddr <<= 1;
02FB:  BCF    03.0
02FC:  RLF    35,F
....................       output_bit (MFRC522_SCK, 0);
02FD:  BCF    03.5
02FE:  BCF    07.3
02FF:  BCF    30.3
0300:  MOVF   30,W
0301:  BSF    03.5
0302:  MOVWF  07
0303:  DECF   34,F
0304:  GOTO   2E3
....................    }
.................... 
....................    
....................    FOR (i = 8; i > 0; i--)
0305:  MOVLW  08
0306:  MOVWF  34
0307:  MOVF   34,F
0308:  BTFSC  03.2
0309:  GOTO   329
....................    {
....................       output_bit (MFRC522_SI, ( (value&0x80) == 0x80));
030A:  MOVF   33,W
030B:  ANDLW  80
030C:  SUBLW  80
030D:  BTFSC  03.2
030E:  GOTO   313
030F:  BCF    03.5
0310:  BCF    07.4
0311:  GOTO   315
0312:  BSF    03.5
0313:  BCF    03.5
0314:  BSF    07.4
0315:  BCF    30.4
0316:  MOVF   30,W
0317:  BSF    03.5
0318:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
0319:  BCF    03.5
031A:  BSF    07.3
031B:  BCF    30.3
031C:  MOVF   30,W
031D:  BSF    03.5
031E:  MOVWF  07
....................       value <<= 1;
031F:  BCF    03.0
0320:  RLF    33,F
....................       output_bit (MFRC522_SCK, 0);
0321:  BCF    03.5
0322:  BCF    07.3
0323:  BCF    30.3
0324:  MOVF   30,W
0325:  BSF    03.5
0326:  MOVWF  07
0327:  DECF   34,F
0328:  GOTO   307
....................    }
.................... 
....................    output_bit (MFRC522_CS, 1);
0329:  BCF    03.5
032A:  BSF    09.0
032B:  BSF    03.5
032C:  BCF    09.0
....................    output_bit (MFRC522_SCK, 1);
032D:  BCF    03.5
032E:  BSF    07.3
032F:  BCF    30.3
0330:  MOVF   30,W
0331:  BSF    03.5
0332:  MOVWF  07
0333:  BCF    03.5
0334:  RETURN
.................... }
.................... static void MFRC522_Clear_Bit( char addr, char mask )
*
0398:  BSF    03.5
0399:  CLRF   30
.................... {     unsigned int8  tmp =0x0; 
....................       tmp=MFRC522_Rd( addr ) ;
039A:  MOVF   2E,W
039B:  MOVWF  31
039C:  BCF    03.5
039D:  CALL   335
039E:  MOVF   78,W
039F:  BSF    03.5
03A0:  MOVWF  30
....................      MFRC522_Wr( addr,  tmp&~mask );     // tmp&(~mask)
03A1:  MOVF   2F,W
03A2:  XORLW  FF
03A3:  ANDWF  30,W
03A4:  MOVWF  31
03A5:  MOVF   2E,W
03A6:  MOVWF  32
03A7:  MOVF   31,W
03A8:  MOVWF  33
03A9:  BCF    03.5
03AA:  CALL   2D4
03AB:  RETURN
.................... }
.................... static void MFRC522_Set_Bit( char addr, char mask )
03AC:  BSF    03.5
03AD:  CLRF   30
.................... {    unsigned int8  tmp =0x0; 
....................       tmp=MFRC522_Rd( addr ) ;  
03AE:  MOVF   2E,W
03AF:  MOVWF  31
03B0:  BCF    03.5
03B1:  CALL   335
03B2:  MOVF   78,W
03B3:  BSF    03.5
03B4:  MOVWF  30
....................      MFRC522_Wr( addr, tmp|mask );
03B5:  MOVF   30,W
03B6:  IORWF  2F,W
03B7:  MOVWF  31
03B8:  MOVF   2E,W
03B9:  MOVWF  32
03BA:  MOVF   31,W
03BB:  MOVWF  33
03BC:  BCF    03.5
03BD:  CALL   2D4
03BE:  RETURN
.................... }
.................... void MFRC522_Reset()
.................... {  
....................    output_bit (MFRC522_RST, 1) ;
*
03C6:  BCF    03.5
03C7:  BSF    09.2
03C8:  BSF    03.5
03C9:  BCF    09.2
....................    delay_us (1);
03CA:  GOTO   3CB
03CB:  GOTO   3CC
03CC:  NOP
....................    output_bit (MFRC522_RST, 0) ;
03CD:  BCF    03.5
03CE:  BCF    09.2
03CF:  BSF    03.5
03D0:  BCF    09.2
....................    delay_us (1);
03D1:  GOTO   3D2
03D2:  GOTO   3D3
03D3:  NOP
....................    output_bit (MFRC522_RST, 1) ;
03D4:  BCF    03.5
03D5:  BSF    09.2
03D6:  BSF    03.5
03D7:  BCF    09.2
....................    delay_us (1);
03D8:  GOTO   3D9
03D9:  GOTO   3DA
03DA:  NOP
....................    MFRC522_Wr( COMMANDREG, PCD_RESETPHASE ); 
03DB:  MOVLW  01
03DC:  MOVWF  32
03DD:  MOVLW  0F
03DE:  MOVWF  33
03DF:  BCF    03.5
03E0:  CALL   2D4
....................    delay_us (1);
03E1:  GOTO   3E2
03E2:  GOTO   3E3
03E3:  NOP
.................... }
.................... void MFRC522_AntennaOn()
.................... {                                               
.................... unsigned int8 stt;
.................... stt= MFRC522_Rd( TXCONTROLREG ) ;
*
0414:  MOVLW  14
0415:  BSF    03.5
0416:  MOVWF  31
0417:  BCF    03.5
0418:  CALL   335
0419:  MOVF   78,W
041A:  MOVWF  67
.................... MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
041B:  MOVLW  14
041C:  BSF    03.5
041D:  MOVWF  2E
041E:  MOVLW  03
041F:  MOVWF  2F
0420:  BCF    03.5
0421:  CALL   3AC
.................... //!if(! (stt&0x03)){                                     
.................... //! MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
.................... //!}
.................... }
.................... void MFRC522_AntennaOff()
.................... {
....................  MFRC522_Clear_Bit( TXCONTROLREG, 0x03 );                                           
*
040D:  MOVLW  14
040E:  BSF    03.5
040F:  MOVWF  2E
0410:  MOVLW  03
0411:  MOVWF  2F
0412:  BCF    03.5
0413:  CALL   398
.................... }
.................... void MFRC522_Init()      
.................... {
....................                                                               
....................     output_bit(MFRC522_CS , 1);  
*
03BF:  BSF    09.0
03C0:  BSF    03.5
03C1:  BCF    09.0
....................     output_bit( MFRC522_RST , 1); 
03C2:  BCF    03.5
03C3:  BSF    09.2
03C4:  BSF    03.5
03C5:  BCF    09.2
....................     
....................      MFRC522_Reset();        
....................      MFRC522_Wr( TMODEREG, 0x8D );      //Tauto=1; f(Timer) = 6.78MHz/TPreScaler
*
03E4:  MOVLW  2A
03E5:  BSF    03.5
03E6:  MOVWF  32
03E7:  MOVLW  8D
03E8:  MOVWF  33
03E9:  BCF    03.5
03EA:  CALL   2D4
....................      MFRC522_Wr( TPRESCALERREG, 0x3E ); //TModeReg[3..0] + TPrescalerReg 
03EB:  MOVLW  2B
03EC:  BSF    03.5
03ED:  MOVWF  32
03EE:  MOVLW  3E
03EF:  MOVWF  33
03F0:  BCF    03.5
03F1:  CALL   2D4
....................      MFRC522_Wr( TRELOADREGL, 30 ); 
03F2:  MOVLW  2D
03F3:  BSF    03.5
03F4:  MOVWF  32
03F5:  MOVLW  1E
03F6:  MOVWF  33
03F7:  BCF    03.5
03F8:  CALL   2D4
....................      MFRC522_Wr( TRELOADREGH, 0 );  
03F9:  MOVLW  2C
03FA:  BSF    03.5
03FB:  MOVWF  32
03FC:  CLRF   33
03FD:  BCF    03.5
03FE:  CALL   2D4
....................      MFRC522_Wr( TXAUTOREG, 0x40 );    //100%ASK
03FF:  MOVLW  15
0400:  BSF    03.5
0401:  MOVWF  32
0402:  MOVLW  40
0403:  MOVWF  33
0404:  BCF    03.5
0405:  CALL   2D4
....................      MFRC522_Wr( MODEREG, 0x3D );      // CRC valor inicial de 0x6363
0406:  MOVLW  11
0407:  BSF    03.5
0408:  MOVWF  32
0409:  MOVLW  3D
040A:  MOVWF  33
040B:  BCF    03.5
040C:  CALL   2D4
....................         
....................      //MFRC522_Clear_Bit( STATUS2REG, 0x08 );//MFCrypto1On=0
....................      //MFRC522_Wr( RXSELREG, 0x86 );      //RxWait = RxSelReg[5..0]
....................      //MFRC522_Wr( RFCFGREG, 0x7F );     //RxGain = 48dB
....................      MFRC522_AntennaOff() ;             
....................      MFRC522_AntennaOn();
*
0422:  BCF    0A.3
0423:  BSF    0A.4
0424:  GOTO   03F (RETURN)
.................... }
.................... char MFRC522_ToCard( char command, char *sendData, char sendLen, char *backData, unsigned *backLen )
*
05A7:  MOVLW  02
05A8:  BSF    03.5
05A9:  MOVWF  28
05AA:  CLRF   29
05AB:  CLRF   2A
.................... {
....................   char _status = MI_ERR;
....................   char irqEn = 0x00;
....................   char waitIRq = 0x00;                
....................   char lastBits;
....................   char n;
....................   unsigned i;
....................   
....................   switch (command)
05AC:  MOVF   20,W
05AD:  XORLW  0E
05AE:  BCF    03.5
05AF:  BTFSC  03.2
05B0:  GOTO   5B5
05B1:  XORLW  02
05B2:  BTFSC  03.2
05B3:  GOTO   5BC
05B4:  GOTO   5C3
....................   {
....................     case PCD_AUTHENT:       //Certification cards close
....................     {
....................       irqEn = 0x12;
05B5:  MOVLW  12
05B6:  BSF    03.5
05B7:  MOVWF  29
....................       waitIRq = 0x10;
05B8:  MOVLW  10
05B9:  MOVWF  2A
....................       break;
05BA:  GOTO   5C4
05BB:  BCF    03.5
....................     }
....................     case PCD_TRANSCEIVE:    //Transmit FIFO data
....................     {
....................       irqEn = 0x77;
05BC:  MOVLW  77
05BD:  BSF    03.5
05BE:  MOVWF  29
....................       waitIRq = 0x30;
05BF:  MOVLW  30
05C0:  MOVWF  2A
....................       break;
05C1:  GOTO   5C4
05C2:  BCF    03.5
....................     }
....................     default:
....................       break;
05C3:  BSF    03.5
....................   }
....................   MFRC522_Wr( COMMIENREG, irqEn | 0x80 );  //Interrupt request
05C4:  MOVF   29,W
05C5:  IORLW  80
05C6:  MOVWF  2E
05C7:  MOVLW  02
05C8:  MOVWF  32
05C9:  MOVF   2E,W
05CA:  MOVWF  33
05CB:  BCF    03.5
05CC:  CALL   2D4
....................   MFRC522_Clear_Bit( COMMIRQREG, 0x80 );   //Clear all interrupt request bit
05CD:  MOVLW  04
05CE:  BSF    03.5
05CF:  MOVWF  2E
05D0:  MOVLW  80
05D1:  MOVWF  2F
05D2:  BCF    03.5
05D3:  CALL   398
....................   MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );   //FlushBuffer=1, FIFO Initialization
05D4:  MOVLW  0A
05D5:  BSF    03.5
05D6:  MOVWF  2E
05D7:  MOVLW  80
05D8:  MOVWF  2F
05D9:  BCF    03.5
05DA:  CALL   3AC
....................   MFRC522_Wr( COMMANDREG, PCD_IDLE );      //NO action; Cancel the current command???
05DB:  MOVLW  01
05DC:  BSF    03.5
05DD:  MOVWF  32
05DE:  CLRF   33
05DF:  BCF    03.5
05E0:  CALL   2D4
....................   
....................   
....................   
....................   //Writing data to the FIFO
....................   for ( i=0; i < sendLen; i++ )
05E1:  BSF    03.5
05E2:  CLRF   2D
05E3:  MOVF   23,W
05E4:  SUBWF  2D,W
05E5:  BTFSC  03.0
05E6:  GOTO   5F8
....................   {
....................     MFRC522_Wr( FIFODATAREG, sendData[i] );
05E7:  MOVF   2D,W
05E8:  ADDWF  21,W
05E9:  MOVWF  04
05EA:  BCF    03.7
05EB:  BTFSC  22.0
05EC:  BSF    03.7
05ED:  MOVF   00,W
05EE:  MOVWF  2E
05EF:  MOVLW  09
05F0:  MOVWF  32
05F1:  MOVF   2E,W
05F2:  MOVWF  33
05F3:  BCF    03.5
05F4:  CALL   2D4
05F5:  BSF    03.5
05F6:  INCF   2D,F
05F7:  GOTO   5E3
....................   }
....................   //Execute the command
....................   MFRC522_Wr( COMMANDREG, command );
05F8:  MOVLW  01
05F9:  MOVWF  32
05FA:  MOVF   20,W
05FB:  MOVWF  33
05FC:  BCF    03.5
05FD:  CALL   2D4
....................   if (command == PCD_TRANSCEIVE )
05FE:  BSF    03.5
05FF:  MOVF   20,W
0600:  SUBLW  0C
0601:  BTFSS  03.2
0602:  GOTO   60A
....................   {
....................     MFRC522_Set_Bit( BITFRAMINGREG, 0x80 ); //StartSend=1,transmission of data starts  
0603:  MOVLW  0D
0604:  MOVWF  2E
0605:  MOVLW  80
0606:  MOVWF  2F
0607:  BCF    03.5
0608:  CALL   3AC
0609:  BSF    03.5
....................   }
....................   //Waiting to receive data to complete
....................   //i according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
....................   i = 0xFFFF;   
060A:  MOVLW  FF
060B:  MOVWF  2D
....................   do
....................   {
....................     //CommIrqReg[7..0]
....................     //Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
....................     n = MFRC522_Rd( COMMIRQREG );
060C:  MOVLW  04
060D:  MOVWF  31
060E:  BCF    03.5
060F:  CALL   335
0610:  MOVF   78,W
0611:  BSF    03.5
0612:  MOVWF  2C
....................     i--;
0613:  DECF   2D,F
....................   }
....................   while ( i && !(n & 0x01) && !( n & waitIRq ) );
0614:  MOVF   2D,F
0615:  BTFSC  03.2
0616:  GOTO   61D
0617:  BTFSC  2C.0
0618:  GOTO   61D
0619:  MOVF   2C,W
061A:  ANDWF  2A,W
061B:  BTFSC  03.2
061C:  GOTO   60C
....................   MFRC522_Clear_Bit( BITFRAMINGREG, 0x80 );    //StartSend=0
061D:  MOVLW  0D
061E:  MOVWF  2E
061F:  MOVLW  80
0620:  MOVWF  2F
0621:  BCF    03.5
0622:  CALL   398
....................   if (i != 0)
0623:  BSF    03.5
0624:  MOVF   2D,F
0625:  BTFSC  03.2
0626:  GOTO   6A1
....................   {
....................     if( !( MFRC522_Rd( ERRORREG ) & 0x1B ) ) //BufferOvfl Collerr CRCErr ProtecolErr
0627:  MOVLW  06
0628:  MOVWF  31
0629:  BCF    03.5
062A:  CALL   335
062B:  MOVF   78,W
062C:  ANDLW  1B
062D:  BTFSS  03.2
062E:  GOTO   69E
....................     {
....................       _status = MI_OK;
062F:  BSF    03.5
0630:  CLRF   28
....................       if ( n & irqEn & 0x01 )
0631:  MOVF   2C,W
0632:  ANDWF  29,W
0633:  ANDLW  01
0634:  BTFSC  03.2
0635:  GOTO   638
....................       {
....................         _status = MI_NOTAGERR;       //??
0636:  MOVLW  01
0637:  MOVWF  28
....................       }
....................       if ( command == PCD_TRANSCEIVE )
0638:  MOVF   20,W
0639:  SUBLW  0C
063A:  BTFSS  03.2
063B:  GOTO   69C
....................       {
....................         n = MFRC522_Rd( FIFOLEVELREG );
063C:  MOVLW  0A
063D:  MOVWF  31
063E:  BCF    03.5
063F:  CALL   335
0640:  MOVF   78,W
0641:  BSF    03.5
0642:  MOVWF  2C
....................         lastBits = MFRC522_Rd( CONTROLREG ) & 0x07;
0643:  MOVLW  0C
0644:  MOVWF  31
0645:  BCF    03.5
0646:  CALL   335
0647:  MOVF   78,W
0648:  ANDLW  07
0649:  BSF    03.5
064A:  MOVWF  2B
....................         if (lastBits)
064B:  MOVF   2B,F
064C:  BTFSC  03.2
064D:  GOTO   65F
....................         {
....................           *backLen = (n-1) * 8 + lastBits;
064E:  MOVF   26,W
064F:  MOVWF  04
0650:  BCF    03.7
0651:  BTFSC  27.0
0652:  BSF    03.7
0653:  MOVLW  01
0654:  SUBWF  2C,W
0655:  MOVWF  77
0656:  RLF    77,F
0657:  RLF    77,F
0658:  RLF    77,F
0659:  MOVLW  F8
065A:  ANDWF  77,F
065B:  MOVF   77,W
065C:  ADDWF  2B,W
065D:  MOVWF  00
....................         }
065E:  GOTO   66C
....................         else
....................         {
....................           *backLen = n * 8;
065F:  MOVF   26,W
0660:  MOVWF  04
0661:  BCF    03.7
0662:  BTFSC  27.0
0663:  BSF    03.7
0664:  RLF    2C,W
0665:  MOVWF  77
0666:  RLF    77,F
0667:  RLF    77,F
0668:  MOVLW  F8
0669:  ANDWF  77,F
066A:  MOVF   77,W
066B:  MOVWF  00
....................         }
....................         if (n == 0)
066C:  MOVF   2C,F
066D:  BTFSS  03.2
066E:  GOTO   671
....................         {
....................           n = 1;
066F:  MOVLW  01
0670:  MOVWF  2C
....................         }
....................         if (n > 16)
0671:  MOVF   2C,W
0672:  SUBLW  10
0673:  BTFSC  03.0
0674:  GOTO   677
....................         {
....................           n = 16;
0675:  MOVLW  10
0676:  MOVWF  2C
....................         }
....................         //Reading the received data in FIFO
....................         for (i=0; i < n; i++)
0677:  CLRF   2D
0678:  MOVF   2C,W
0679:  SUBWF  2D,W
067A:  BTFSC  03.0
067B:  GOTO   695
....................         {
....................           backData[i] = MFRC522_Rd( FIFODATAREG );
067C:  MOVF   2D,W
067D:  ADDWF  24,W
067E:  MOVWF  78
067F:  MOVF   25,W
0680:  MOVWF  7A
0681:  BTFSC  03.0
0682:  INCF   7A,F
0683:  MOVF   78,W
0684:  MOVWF  2E
0685:  MOVF   7A,W
0686:  MOVWF  2F
0687:  MOVLW  09
0688:  MOVWF  31
0689:  BCF    03.5
068A:  CALL   335
068B:  BSF    03.5
068C:  MOVF   2E,W
068D:  MOVWF  04
068E:  BCF    03.7
068F:  BTFSC  2F.0
0690:  BSF    03.7
0691:  MOVF   78,W
0692:  MOVWF  00
0693:  INCF   2D,F
0694:  GOTO   678
....................         }
....................   
....................   backData[i] = 0;
0695:  MOVF   2D,W
0696:  ADDWF  24,W
0697:  MOVWF  04
0698:  BCF    03.7
0699:  BTFSC  25.0
069A:  BSF    03.7
069B:  CLRF   00
....................       }
....................     }
069C:  GOTO   6A1
069D:  BCF    03.5
....................     else
....................     {
....................       _status = MI_ERR;
069E:  MOVLW  02
069F:  BSF    03.5
06A0:  MOVWF  28
....................     }
....................   }
....................   //MFRC522_Set_Bit( CONTROLREG, 0x80 );
....................   //MFRC522_Wr( COMMANDREG, PCD_IDLE );
....................   return _status;
06A1:  MOVF   28,W
06A2:  MOVWF  78
06A3:  BCF    03.5
06A4:  RETURN
.................... }
.................... char MFRC522_Request( char reqMode, char *TagType )
.................... {
....................   char _status;
....................   unsigned backBits;            //The received data bits
....................   MFRC522_Wr( BITFRAMINGREG, 0x07 ); //TxLastBists = BitFramingReg[2..0]   ???
*
06AB:  MOVLW  0D
06AC:  BSF    03.5
06AD:  MOVWF  32
06AE:  MOVLW  07
06AF:  MOVWF  33
06B0:  BCF    03.5
06B1:  CALL   2D4
....................   TagType[0] = reqMode;
06B2:  MOVF   74,W
06B3:  MOVWF  04
06B4:  BCF    03.7
06B5:  BTFSC  75.0
06B6:  BSF    03.7
06B7:  MOVF   73,W
06B8:  MOVWF  00
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, TagType, 1, TagType, &backBits );
06B9:  MOVLW  0C
06BA:  BSF    03.5
06BB:  MOVWF  20
06BC:  MOVF   75,W
06BD:  MOVWF  22
06BE:  MOVF   74,W
06BF:  MOVWF  21
06C0:  MOVLW  01
06C1:  MOVWF  23
06C2:  MOVF   75,W
06C3:  MOVWF  25
06C4:  MOVF   74,W
06C5:  MOVWF  24
06C6:  CLRF   27
06C7:  MOVLW  7B
06C8:  MOVWF  26
06C9:  BCF    03.5
06CA:  CALL   5A7
06CB:  MOVF   78,W
06CC:  MOVWF  76
....................   if ( (_status != MI_OK) || (backBits != 0x10) )
06CD:  MOVF   76,F
06CE:  BTFSS  03.2
06CF:  GOTO   6D4
06D0:  MOVF   7B,W
06D1:  SUBLW  10
06D2:  BTFSC  03.2
06D3:  GOTO   6D6
....................   {
....................     _status = MI_ERR;
06D4:  MOVLW  02
06D5:  MOVWF  76
....................   }
....................   return _status;
06D6:  MOVF   76,W
06D7:  MOVWF  78
.................... }
.................... void MFRC522_CRC( char *dataIn, char length, char *dataOut )
.................... {
.................... char i, n;
....................     MFRC522_Clear_Bit( DIVIRQREG, 0x04 );
*
0754:  MOVLW  05
0755:  BSF    03.5
0756:  MOVWF  2E
0757:  MOVLW  04
0758:  MOVWF  2F
0759:  BCF    03.5
075A:  CALL   398
....................     MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );    
075B:  MOVLW  0A
075C:  BSF    03.5
075D:  MOVWF  2E
075E:  MOVLW  80
075F:  MOVWF  2F
0760:  BCF    03.5
0761:  CALL   3AC
....................     
....................  //Escreve dados no FIFO        
....................     for ( i = 0; i < length; i++ )
0762:  BSF    03.5
0763:  CLRF   20
0764:  MOVF   76,W
0765:  SUBWF  20,W
0766:  BTFSC  03.0
0767:  GOTO   77D
....................     {   
....................         MFRC522_Wr( FIFODATAREG, *dataIn++ );   
0768:  MOVF   7C,W
0769:  MOVWF  7A
076A:  MOVF   7B,W
076B:  INCF   7B,F
076C:  BTFSC  03.2
076D:  INCF   7C,F
076E:  MOVWF  04
076F:  BCF    03.7
0770:  BTFSC  7A.0
0771:  BSF    03.7
0772:  MOVF   00,W
0773:  MOVWF  22
0774:  MOVLW  09
0775:  MOVWF  32
0776:  MOVF   22,W
0777:  MOVWF  33
0778:  BCF    03.5
0779:  CALL   2D4
077A:  BSF    03.5
077B:  INCF   20,F
077C:  GOTO   764
....................     }
....................     
....................     MFRC522_Wr( COMMANDREG, PCD_CALCCRC );
077D:  MOVLW  01
077E:  MOVWF  32
077F:  MOVLW  03
0780:  MOVWF  33
0781:  BCF    03.5
0782:  CALL   2D4
....................         
....................     i = 0xFF;
0783:  MOVLW  FF
0784:  BSF    03.5
0785:  MOVWF  20
....................     //Espera a finalizao do Calculo do CRC
....................     do 
....................     {
....................         n = MFRC522_Rd( DIVIRQREG );
0786:  MOVLW  05
0787:  MOVWF  31
0788:  BCF    03.5
0789:  CALL   335
078A:  MOVF   78,W
078B:  BSF    03.5
078C:  MOVWF  21
....................         i--;
078D:  DECF   20,F
....................     }
....................     while( i && !(n & 0x04) );        //CRCIrq = 1
078E:  MOVF   20,F
078F:  BTFSC  03.2
0790:  GOTO   793
0791:  BTFSS  21.2
0792:  GOTO   786
....................         
....................     dataOut[0] = MFRC522_Rd( CRCRESULTREGL );
0793:  MOVF   7D,W
0794:  MOVWF  78
0795:  MOVF   7E,W
0796:  MOVWF  7A
0797:  MOVF   7D,W
0798:  MOVWF  22
0799:  MOVF   7E,W
079A:  MOVWF  23
079B:  MOVLW  22
079C:  MOVWF  31
079D:  BCF    03.5
079E:  CALL   335
079F:  BSF    03.5
07A0:  MOVF   22,W
07A1:  MOVWF  04
07A2:  BCF    03.7
07A3:  BTFSC  23.0
07A4:  BSF    03.7
07A5:  MOVF   78,W
07A6:  MOVWF  00
....................     dataOut[1] = MFRC522_Rd( CRCRESULTREGM );        
07A7:  MOVLW  01
07A8:  ADDWF  7D,W
07A9:  MOVWF  78
07AA:  MOVF   7E,W
07AB:  MOVWF  7A
07AC:  BTFSC  03.0
07AD:  INCF   7A,F
07AE:  MOVF   78,W
07AF:  MOVWF  22
07B0:  MOVF   7A,W
07B1:  MOVWF  23
07B2:  MOVLW  21
07B3:  MOVWF  31
07B4:  BCF    03.5
07B5:  CALL   335
07B6:  BSF    03.5
07B7:  MOVF   22,W
07B8:  MOVWF  04
07B9:  BCF    03.7
07BA:  BTFSC  23.0
07BB:  BSF    03.7
07BC:  MOVF   78,W
07BD:  MOVWF  00
.................... }
.................... char MFRC522_SelectTag( char *serNum )
.................... {
....................   char i;
....................   char _status;
....................   char size;
....................   unsigned recvBits;
....................   char buffer[9];
....................   
....................   //MFRC522_Clear_Bit( STATUS2REG, 0x08 );   //MFCrypto1On=0
....................   
....................   buffer[0] = PICC_SElECTTAG;
....................   buffer[1] = 0x70;
....................   
....................   for ( i=2; i < 7; i++ )
....................   {
....................     buffer[i] = *serNum++;
....................   }
....................   
....................   MFRC522_CRC( buffer, 7, &buffer[7] );             
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits );
....................   if ( (_status == MI_OK) && (recvBits == 0x18) )
....................   {
....................     size = buffer[0];
....................   }
....................   else
....................   {
....................     size = 0;
....................   }
....................   return size;
.................... }
.................... //hibernation
.................... void MFRC522_Halt()
.................... {
....................   unsigned unLen;
....................   char buff[4];
....................   
....................   buff[0] = PICC_HALT;
*
0749:  MOVLW  50
074A:  MOVWF  72
....................   buff[1] = 0;
074B:  CLRF   73
....................   MFRC522_CRC( buff, 2, &buff[2] );
074C:  CLRF   7C
074D:  MOVLW  72
074E:  MOVWF  7B
074F:  MOVLW  02
0750:  MOVWF  76
0751:  CLRF   7E
0752:  MOVLW  74
0753:  MOVWF  7D
....................   MFRC522_Clear_Bit( STATUS2REG, 0x80 );
*
07BE:  MOVLW  08
07BF:  MOVWF  2E
07C0:  MOVLW  80
07C1:  MOVWF  2F
07C2:  BCF    03.5
07C3:  CALL   398
....................   MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &unLen );
07C4:  MOVLW  0C
07C5:  BSF    03.5
07C6:  MOVWF  20
07C7:  CLRF   22
07C8:  MOVLW  72
07C9:  MOVWF  21
07CA:  MOVLW  04
07CB:  MOVWF  23
07CC:  CLRF   25
07CD:  MOVLW  72
07CE:  MOVWF  24
07CF:  CLRF   27
07D0:  MOVLW  71
07D1:  MOVWF  26
07D2:  BCF    03.5
07D3:  CALL   5A7
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
07D4:  MOVLW  08
07D5:  BSF    03.5
07D6:  MOVWF  2E
07D7:  MOVWF  2F
07D8:  BCF    03.5
07D9:  CALL   398
07DA:  RETURN
.................... }
.................... char MFRC522_Auth( char authMode, char BlockAddr, char *Sectorkey, char *serNum )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[12];
....................   
....................   //Verify the command block address + sector + password + card serial number
....................   buff[0] = authMode;
....................   buff[1] = BlockAddr;
....................   
....................   for ( i = 2; i < 8; i++ )
....................   {
....................     buff[i] = Sectorkey[i-2];
....................   }
....................   
....................   for ( i = 8; i < 12; i++ )
....................   {
....................     buff[i] = serNum[i-8];
....................   }
....................   
....................   _status = MFRC522_ToCard( PCD_AUTHENT, buff, 12, buff, &recvBits );
....................   
....................   if ( ( _status != MI_OK ) || !( MFRC522_Rd( STATUS2REG ) & 0x08 ) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   
....................   return _status;
.................... }
.................... char MFRC522_Write( char blockAddr, char *writeData )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[18];
....................   buff[0] = PICC_WRITE;
....................   buff[1] = blockAddr;
....................   
....................   MFRC522_CRC( buff, 2, &buff[2] );
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &recvBits );
....................   if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   if (_status == MI_OK)
....................   {
....................     for ( i = 0; i < 16; i++ )                //Data to the FIFO write 16Byte
....................     {
....................       buff[i] = writeData[i];
....................     }
....................     
....................     MFRC522_CRC( buff, 16, &buff[16] );
....................     _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 18, buff, &recvBits );
....................     if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A ) )
....................     {
....................       _status = MI_ERR;
....................     }
....................   }
....................   return _status;
.................... }
.................... char MFRC522_Read( char blockAddr, char *recvData )
.................... {
....................   char _status;
....................   unsigned unLen;
....................   recvData[0] = PICC_READ;
....................   recvData[1] = blockAddr;
....................   
....................   MFRC522_CRC( recvData, 2, &recvData[2] );
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, recvData, 4, recvData, &unLen );
....................   if ( (_status != MI_OK) || (unLen != 0x90) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   return _status;
.................... }
.................... char MFRC522_AntiColl( char *serNum )
*
06E6:  CLRF   7C
.................... {
....................   char _status;
....................   char i;
....................   char serNumCheck = 0;
....................   unsigned unLen;
....................   MFRC522_Wr( BITFRAMINGREG, 0x00 );                //TxLastBists = BitFramingReg[2..0]
06E7:  MOVLW  0D
06E8:  BSF    03.5
06E9:  MOVWF  32
06EA:  CLRF   33
06EB:  BCF    03.5
06EC:  CALL   2D4
....................   serNum[0] = PICC_ANTICOLL;
06ED:  MOVF   74,W
06EE:  MOVWF  04
06EF:  BCF    03.7
06F0:  BTFSC  75.0
06F1:  BSF    03.7
06F2:  MOVLW  93
06F3:  MOVWF  00
....................   serNum[1] = 0x20;
06F4:  MOVLW  01
06F5:  ADDWF  74,W
06F6:  MOVWF  04
06F7:  BCF    03.7
06F8:  BTFSC  75.0
06F9:  BSF    03.7
06FA:  MOVLW  20
06FB:  MOVWF  00
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
06FC:  MOVLW  08
06FD:  BSF    03.5
06FE:  MOVWF  2E
06FF:  MOVWF  2F
0700:  BCF    03.5
0701:  CALL   398
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, serNum, 2, serNum, &unLen );
0702:  MOVLW  0C
0703:  BSF    03.5
0704:  MOVWF  20
0705:  MOVF   75,W
0706:  MOVWF  22
0707:  MOVF   74,W
0708:  MOVWF  21
0709:  MOVLW  02
070A:  MOVWF  23
070B:  MOVF   75,W
070C:  MOVWF  25
070D:  MOVF   74,W
070E:  MOVWF  24
070F:  CLRF   27
0710:  MOVLW  7D
0711:  MOVWF  26
0712:  BCF    03.5
0713:  CALL   5A7
0714:  MOVF   78,W
0715:  MOVWF  76
....................   if (_status == MI_OK)
0716:  MOVF   76,F
0717:  BTFSS  03.2
0718:  GOTO   734
....................   {
....................     for ( i=0; i < 4; i++ )
0719:  CLRF   7B
071A:  MOVF   7B,W
071B:  SUBLW  03
071C:  BTFSS  03.0
071D:  GOTO   728
....................     {
....................       serNumCheck ^= serNum[i];
071E:  MOVF   7B,W
071F:  ADDWF  74,W
0720:  MOVWF  04
0721:  BCF    03.7
0722:  BTFSC  75.0
0723:  BSF    03.7
0724:  MOVF   00,W
0725:  XORWF  7C,F
0726:  INCF   7B,F
0727:  GOTO   71A
....................     }
....................     
....................     if ( serNumCheck != serNum[4] )
0728:  MOVLW  04
0729:  ADDWF  74,W
072A:  MOVWF  04
072B:  BCF    03.7
072C:  BTFSC  75.0
072D:  BSF    03.7
072E:  MOVF   00,W
072F:  SUBWF  7C,W
0730:  BTFSC  03.2
0731:  GOTO   734
....................     {
....................       _status = MI_ERR;
0732:  MOVLW  02
0733:  MOVWF  76
....................     }
....................   }
....................   return _status;
0734:  MOVF   76,W
0735:  MOVWF  78
.................... }
.................... //0x0044 = Mifare_UltraLight
.................... //0x0004 = Mifare_One (S50)
.................... //0x0002 = Mifare_One (S70)
.................... //0x0008 = Mifare_Pro (X)
.................... //0x0344 = Mifare_DESFire
.................... char MFRC522_isCard( char *TagType ) 
.................... {
....................     if (MFRC522_Request( PICC_REQIDL, TagType ) == MI_OK)
*
06A5:  MOVLW  26
06A6:  MOVWF  73
06A7:  MOVF   72,W
06A8:  MOVWF  75
06A9:  MOVF   71,W
06AA:  MOVWF  74
*
06D8:  MOVF   78,F
06D9:  BTFSS  03.2
06DA:  GOTO   6DF
....................         return 1;
06DB:  MOVLW  01
06DC:  MOVWF  78
06DD:  GOTO   6E1
06DE:  GOTO   6E1
....................     else
....................         return 0; 
06DF:  MOVLW  00
06E0:  MOVWF  78
06E1:  RETURN
.................... }
.................... char MFRC522_ReadCardSerial( char *str )
.................... {
.................... char _status; 
....................  _status = MFRC522_AntiColl( str );
06E2:  MOVF   72,W
06E3:  MOVWF  75
06E4:  MOVF   71,W
06E5:  MOVWF  74
*
0736:  MOVF   78,W
0737:  MOVWF  73
....................  str[5] = 0;
0738:  MOVLW  05
0739:  ADDWF  71,W
073A:  MOVWF  04
073B:  BCF    03.7
073C:  BTFSC  72.0
073D:  BSF    03.7
073E:  CLRF   00
....................  if (_status == MI_OK)
073F:  MOVF   73,F
0740:  BTFSS  03.2
0741:  GOTO   746
....................   return 1;
0742:  MOVLW  01
0743:  MOVWF  78
0744:  GOTO   748
0745:  GOTO   748
....................  else
....................   return 0;
0746:  MOVLW  00
0747:  MOVWF  78
0748:  RETURN
.................... }
.................... 
.................... //#include <read_card.h>
.................... //#include <unlock.h>
.................... 
.................... 
.................... #define pass_add 0x04
.................... #define card_add 0x24
.................... #define card_num_add 0x14
.................... 
.................... 
.................... char *key_UID;
.................... unsigned int TagType;  
.................... int8 checkpass; 
.................... int8 keypad,key;
.................... int8 pass[5];
.................... int8 rightpass[5];
.................... int8 rightid[5];                ////= {0xe0, 0x10, 0x02, 0xa8, 0x5a};
.................... //int8 *card_UID;
.................... int8 matchpass=0, matchcard=0;
.................... int8 card_num;
.................... //int8 eeppass[6];
....................    
.................... void _CaiDatLCD(void);
.................... void lcd_clear(void);
.................... void clear_UID(void);
.................... unsigned int8 *card_id();
.................... void door(void);
.................... void lockdoor(void);
.................... void enter_pass(void);
.................... void check_pass(int8 *c);
.................... void scan_card(void);
.................... void check_card(void);
.................... void help(void);
.................... void eeprom_w_pass(unsigned int8 addr, unsigned char*arr);
.................... void eeprom_r_pass(unsigned int8 addr, unsigned char*arr);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... void main()
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  30
1005:  CLRF   46
1006:  CLRF   47
1007:  CLRF   4A
1008:  CLRF   49
1009:  BSF    03.5
100A:  BSF    03.6
100B:  MOVF   09,W
100C:  ANDLW  C0
100D:  MOVWF  09
100E:  BCF    03.6
100F:  BCF    1F.4
1010:  BCF    1F.5
1011:  MOVLW  00
1012:  BSF    03.6
1013:  MOVWF  08
1014:  BCF    03.5
1015:  CLRF   07
1016:  CLRF   08
1017:  CLRF   09
1018:  BCF    03.7
.................... {  
....................    _CaiDatLCD();
*
103A:  BCF    0A.4
103B:  GOTO   297
103C:  BSF    0A.4
....................    MFRC522_Init ();
103D:  BCF    0A.4
103E:  GOTO   3BF
103F:  BSF    0A.4
....................    keypad_init();
1040:  BCF    0A.4
1041:  GOTO   45C
1042:  BSF    0A.4
....................    card_num=read_eeprom(card_num_add);
1043:  MOVLW  14
1044:  BSF    03.6
1045:  MOVWF  0D
1046:  BSF    03.5
1047:  BCF    0C.7
1048:  BSF    0C.0
1049:  BCF    03.5
104A:  MOVF   0C,W
104B:  BCF    03.6
104C:  MOVWF  48
....................    if(card_num==0xff) write_eeprom(card_num_add,0);
104D:  INCFSZ 48,W
104E:  GOTO   065
104F:  MOVF   0B,W
1050:  MOVWF  77
1051:  BCF    0B.7
1052:  MOVLW  14
1053:  BSF    03.6
1054:  MOVWF  0D
1055:  CLRF   0C
1056:  BSF    03.5
1057:  BCF    0C.7
1058:  BSF    0C.2
1059:  MOVLW  55
105A:  MOVWF  0D
105B:  MOVLW  AA
105C:  MOVWF  0D
105D:  BSF    0C.1
105E:  BTFSC  0C.1
105F:  GOTO   05E
1060:  BCF    0C.2
1061:  MOVF   77,W
1062:  BCF    03.5
1063:  BCF    03.6
1064:  IORWF  0B,F
....................    
....................    eeprom_r_pass(0x04, rightpass);
1065:  MOVLW  04
1066:  MOVWF  72
1067:  CLRF   74
1068:  MOVLW  3C
1069:  MOVWF  73
106A:  BCF    0A.4
106B:  CALL   46B
106C:  BSF    0A.4
....................    int8 k=0, checkeep=0;
106D:  CLRF   4B
106E:  CLRF   4C
....................    for(k=0;k<5;k++){
106F:  CLRF   4B
1070:  MOVF   4B,W
1071:  SUBLW  04
1072:  BTFSS  03.0
1073:  GOTO   07D
....................       if(rightpass[k]==0xff) checkeep++;
1074:  MOVLW  3C
1075:  ADDWF  4B,W
1076:  MOVWF  04
1077:  BCF    03.7
1078:  INCFSZ 00,W
1079:  GOTO   07B
107A:  INCF   4C,F
107B:  INCF   4B,F
107C:  GOTO   070
....................    }
....................    if(checkeep == 5){
107D:  MOVF   4C,W
107E:  SUBLW  05
107F:  BTFSS  03.2
1080:  GOTO   0F2
....................       lcd_gotoxy(1,1);
1081:  MOVLW  01
1082:  MOVWF  6F
1083:  MOVWF  70
1084:  BCF    0A.4
1085:  CALL   250
1086:  BSF    0A.4
....................       printf(lcd_putc," ENTER NEW PASS ");
1087:  MOVLW  0C
1088:  BSF    03.6
1089:  MOVWF  0D
108A:  MOVLW  00
108B:  MOVWF  0F
108C:  BCF    0A.4
108D:  BCF    03.6
108E:  CALL   486
108F:  BSF    0A.4
....................       lcd_gotoxy(6,2);
1090:  MOVLW  06
1091:  MOVWF  6F
1092:  MOVLW  02
1093:  MOVWF  70
1094:  BCF    0A.4
1095:  CALL   250
1096:  BSF    0A.4
....................       int8 m=0;
1097:  CLRF   4D
....................       while(m<5){
1098:  MOVF   4D,W
1099:  SUBLW  04
109A:  BTFSS  03.0
109B:  GOTO   0ED
....................          key=scan();
109C:  BCF    0A.4
109D:  CALL   4DC
109E:  BSF    0A.4
109F:  MOVF   78,W
10A0:  MOVWF  36
....................          if(key){
10A1:  MOVF   36,F
10A2:  BTFSC  03.2
10A3:  GOTO   0EC
....................             keypad = phimnhan[key-1];
10A4:  MOVLW  01
10A5:  SUBWF  36,W
10A6:  ADDLW  20
10A7:  MOVWF  04
10A8:  BCF    03.7
10A9:  MOVF   00,W
10AA:  MOVWF  35
....................             if(keypad>='0' && keypad<='9'){
10AB:  MOVF   35,W
10AC:  SUBLW  2F
10AD:  BTFSC  03.0
10AE:  GOTO   0EC
10AF:  MOVF   35,W
10B0:  SUBLW  39
10B1:  BTFSS  03.0
10B2:  GOTO   0EC
....................                printf(lcd_putc,"%c",keypad);
10B3:  MOVF   35,W
10B4:  MOVWF  6E
10B5:  BCF    0A.4
10B6:  CALL   273
10B7:  BSF    0A.4
....................                write_eeprom(0x04+m, keypad);
10B8:  MOVLW  04
10B9:  ADDWF  4D,W
10BA:  MOVWF  67
10BB:  MOVF   0B,W
10BC:  MOVWF  77
10BD:  BCF    0B.7
10BE:  MOVF   67,W
10BF:  BSF    03.6
10C0:  MOVWF  0D
10C1:  BCF    03.6
10C2:  MOVF   35,W
10C3:  BSF    03.6
10C4:  MOVWF  0C
10C5:  BSF    03.5
10C6:  BCF    0C.7
10C7:  BSF    0C.2
10C8:  MOVLW  55
10C9:  MOVWF  0D
10CA:  MOVLW  AA
10CB:  MOVWF  0D
10CC:  BSF    0C.1
10CD:  BTFSC  0C.1
10CE:  GOTO   0CD
10CF:  BCF    0C.2
10D0:  MOVF   77,W
10D1:  BCF    03.5
10D2:  BCF    03.6
10D3:  IORWF  0B,F
....................                delay_ms(300);
10D4:  MOVLW  02
10D5:  MOVWF  67
10D6:  MOVLW  96
10D7:  MOVWF  6A
10D8:  BCF    0A.4
10D9:  CALL   573
10DA:  BSF    0A.4
10DB:  DECFSZ 67,F
10DC:  GOTO   0D6
....................                lcd_gotoxy(6+m,2);
10DD:  MOVLW  06
10DE:  ADDWF  4D,W
10DF:  MOVWF  67
10E0:  MOVWF  6F
10E1:  MOVLW  02
10E2:  MOVWF  70
10E3:  BCF    0A.4
10E4:  CALL   250
10E5:  BSF    0A.4
....................                printf(lcd_putc,"*");
10E6:  MOVLW  2A
10E7:  MOVWF  6E
10E8:  BCF    0A.4
10E9:  CALL   273
10EA:  BSF    0A.4
....................                m++;
10EB:  INCF   4D,F
....................             }
....................          }
10EC:  GOTO   098
....................       }
....................       lcd_putc('\f');
10ED:  MOVLW  0C
10EE:  MOVWF  6E
10EF:  BCF    0A.4
10F0:  CALL   273
10F1:  BSF    0A.4
....................    }
....................    
....................    eeprom_r_pass(0x04, rightpass);
10F2:  MOVLW  04
10F3:  MOVWF  72
10F4:  CLRF   74
10F5:  MOVLW  3C
10F6:  MOVWF  73
10F7:  BCF    0A.4
10F8:  CALL   46B
10F9:  BSF    0A.4
....................    
....................    lockdoor();
10FA:  BCF    0A.4
10FB:  CALL   587
10FC:  BSF    0A.4
....................    lcd_gotoxy(1,1);//dinh vi toa do muon hien thi ki tu len LCD
10FD:  MOVLW  01
10FE:  MOVWF  6F
10FF:  MOVWF  70
1100:  BCF    0A.4
1101:  CALL   250
1102:  BSF    0A.4
....................    printf(lcd_putc,"    WELCOME!");//hien thi chuoi ki tu len LCD
1103:  MOVLW  15
1104:  BSF    03.6
1105:  MOVWF  0D
1106:  MOVLW  00
1107:  MOVWF  0F
1108:  BCF    0A.4
1109:  BCF    03.6
110A:  CALL   486
110B:  BSF    0A.4
....................    //delay_ms(2000);
....................    lcd_gotoxy(1,1);
110C:  MOVLW  01
110D:  MOVWF  6F
110E:  MOVWF  70
110F:  BCF    0A.4
1110:  CALL   250
1111:  BSF    0A.4
....................    printf(lcd_putc,"  DOOR   LOCK   ");
1112:  MOVLW  1C
1113:  BSF    03.6
1114:  MOVWF  0D
1115:  MOVLW  00
1116:  MOVWF  0F
1117:  BCF    0A.4
1118:  BCF    03.6
1119:  CALL   486
111A:  BSF    0A.4
....................    lcd_gotoxy(1,2);
111B:  MOVLW  01
111C:  MOVWF  6F
111D:  MOVLW  02
111E:  MOVWF  70
111F:  BCF    0A.4
1120:  CALL   250
1121:  BSF    0A.4
....................    printf(lcd_putc,"PRESS # TO HELP!");
1122:  MOVLW  25
1123:  BSF    03.6
1124:  MOVWF  0D
1125:  MOVLW  00
1126:  MOVWF  0F
1127:  BCF    0A.4
1128:  BCF    03.6
1129:  CALL   486
112A:  BSF    0A.4
....................    
....................    while(TRUE)
....................    {     
....................      // card_num = 0xff- read_eeprom(card_num_add);
....................       scan_card();
112B:  BCF    0A.4
112C:  BSF    0A.3
112D:  CALL   000
112E:  BSF    0A.4
112F:  BCF    0A.3
....................       check_card();
1130:  BCF    0A.4
1131:  BSF    0A.3
1132:  CALL   0B8
1133:  BSF    0A.4
1134:  BCF    0A.3
....................       key=0; keypad=0;
1135:  CLRF   36
1136:  CLRF   35
....................       delay_ms(200);
1137:  MOVLW  C8
1138:  MOVWF  6A
1139:  BCF    0A.4
113A:  CALL   573
113B:  BSF    0A.4
....................       key = scan();
113C:  BCF    0A.4
113D:  CALL   4DC
113E:  BSF    0A.4
113F:  MOVF   78,W
1140:  MOVWF  36
....................       if(key){
1141:  MOVF   36,F
1142:  BTFSC  03.2
1143:  GOTO   5F3
....................          keypad=phimnhan[key-1];
1144:  MOVLW  01
1145:  SUBWF  36,W
1146:  ADDLW  20
1147:  MOVWF  04
1148:  BCF    03.7
1149:  MOVF   00,W
114A:  MOVWF  35
....................          
....................          if(keypad == '#'){
114B:  MOVF   35,W
114C:  SUBLW  23
114D:  BTFSS  03.2
114E:  GOTO   154
....................             help();   
114F:  BCF    0A.4
1150:  BSF    0A.3
1151:  GOTO   0CB
1152:  BSF    0A.4
1153:  BCF    0A.3
....................          }
....................          lockdoor();
1154:  BCF    0A.4
1155:  CALL   587
1156:  BSF    0A.4
.................... /*****************************************************************************/         
....................          if(keypad == 'A'){
1157:  MOVF   35,W
1158:  SUBLW  41
1159:  BTFSS  03.2
115A:  GOTO   16D
....................             while(TRUE){
....................                enter_pass(); 
115B:  BCF    0A.4
115C:  BSF    0A.3
115D:  CALL   184
115E:  BSF    0A.4
115F:  BCF    0A.3
....................                check_pass(&checkpass);
1160:  CLRF   68
1161:  MOVLW  34
1162:  MOVWF  67
1163:  BCF    0A.4
1164:  BSF    0A.3
1165:  GOTO   224
1166:  BSF    0A.4
1167:  BCF    0A.3
....................                if(checkpass) break;
1168:  MOVF   34,F
1169:  BTFSC  03.2
116A:  GOTO   16C
116B:  GOTO   16D
116C:  GOTO   15B
....................             }   
....................          }
....................          lockdoor();
116D:  BCF    0A.4
116E:  CALL   587
116F:  BSF    0A.4
....................          
.................... /*****************************************************************************/
....................          if(keypad == 'B'){
1170:  MOVF   35,W
1171:  SUBLW  42
1172:  BTFSS  03.2
1173:  GOTO   359
....................             int8 done=1;
1174:  MOVLW  01
1175:  MOVWF  4E
....................             while(done){
1176:  MOVF   4E,F
1177:  BTFSC  03.2
1178:  GOTO   359
....................                lcd_putc('\f');
1179:  MOVLW  0C
117A:  MOVWF  6E
117B:  BCF    0A.4
117C:  CALL   273
117D:  BSF    0A.4
....................                lcd_gotoxy(1,1);
117E:  MOVLW  01
117F:  MOVWF  6F
1180:  MOVWF  70
1181:  BCF    0A.4
1182:  CALL   250
1183:  BSF    0A.4
....................                printf(lcd_putc, " ENTER OLD PASS ");
1184:  MOVLW  2E
1185:  BSF    03.6
1186:  MOVWF  0D
1187:  MOVLW  00
1188:  MOVWF  0F
1189:  BCF    0A.4
118A:  BCF    03.6
118B:  CALL   486
118C:  BSF    0A.4
....................                delay_ms(500);
118D:  MOVLW  02
118E:  MOVWF  67
118F:  MOVLW  FA
1190:  MOVWF  6A
1191:  BCF    0A.4
1192:  CALL   573
1193:  BSF    0A.4
1194:  DECFSZ 67,F
1195:  GOTO   18F
....................                lcd_gotoxy(6,2);
1196:  MOVLW  06
1197:  MOVWF  6F
1198:  MOVLW  02
1199:  MOVWF  70
119A:  BCF    0A.4
119B:  CALL   250
119C:  BSF    0A.4
....................                int8 i=0;
119D:  CLRF   4F
....................                matchpass=0;
119E:  CLRF   46
....................                while(i<5){
119F:  MOVF   4F,W
11A0:  SUBLW  04
11A1:  BTFSS  03.0
11A2:  GOTO   20F
....................                   //scan_card();
....................                   //check_card();
....................                   //if(matchpass==7) break;
....................                   key = scan();
11A3:  BCF    0A.4
11A4:  CALL   4DC
11A5:  BSF    0A.4
11A6:  MOVF   78,W
11A7:  MOVWF  36
....................                   if(key){
11A8:  MOVF   36,F
11A9:  BTFSC  03.2
11AA:  GOTO   20E
....................                      keypad=phimnhan[key-1];
11AB:  MOVLW  01
11AC:  SUBWF  36,W
11AD:  ADDLW  20
11AE:  MOVWF  04
11AF:  BCF    03.7
11B0:  MOVF   00,W
11B1:  MOVWF  35
....................                      if(keypad=='#'){
11B2:  MOVF   35,W
11B3:  SUBLW  23
11B4:  BTFSS  03.2
11B5:  GOTO   1B9
....................                         matchpass=8;
11B6:  MOVLW  08
11B7:  MOVWF  46
....................                         break; ///////////////////////////////////////////////
11B8:  GOTO   20F
....................                      }
....................                      if(keypad=='*'){
11B9:  MOVF   35,W
11BA:  SUBLW  2A
11BB:  BTFSS  03.2
11BC:  GOTO   1D7
....................                         lcd_gotoxy(6,2); printf(lcd_putc,"          ");
11BD:  MOVLW  06
11BE:  MOVWF  6F
11BF:  MOVLW  02
11C0:  MOVWF  70
11C1:  BCF    0A.4
11C2:  CALL   250
11C3:  BSF    0A.4
11C4:  MOVLW  37
11C5:  BSF    03.6
11C6:  MOVWF  0D
11C7:  MOVLW  00
11C8:  MOVWF  0F
11C9:  BCF    0A.4
11CA:  BCF    03.6
11CB:  CALL   486
11CC:  BSF    0A.4
....................                         lcd_gotoxy(6,2); i=0; matchpass=0; 
11CD:  MOVLW  06
11CE:  MOVWF  6F
11CF:  MOVLW  02
11D0:  MOVWF  70
11D1:  BCF    0A.4
11D2:  CALL   250
11D3:  BSF    0A.4
11D4:  CLRF   4F
11D5:  CLRF   46
....................                         continue;//////////////////////////////////
11D6:  GOTO   19F
....................                      }
....................                      printf(lcd_putc,"%c",keypad);
11D7:  MOVF   35,W
11D8:  MOVWF  6E
11D9:  BCF    0A.4
11DA:  CALL   273
11DB:  BSF    0A.4
....................                      lcd_gotoxy(6+i,2); delay_ms(200);
11DC:  MOVLW  06
11DD:  ADDWF  4F,W
11DE:  MOVWF  67
11DF:  MOVWF  6F
11E0:  MOVLW  02
11E1:  MOVWF  70
11E2:  BCF    0A.4
11E3:  CALL   250
11E4:  BSF    0A.4
11E5:  MOVLW  C8
11E6:  MOVWF  6A
11E7:  BCF    0A.4
11E8:  CALL   573
11E9:  BSF    0A.4
....................                      printf(lcd_putc,"*");
11EA:  MOVLW  2A
11EB:  MOVWF  6E
11EC:  BCF    0A.4
11ED:  CALL   273
11EE:  BSF    0A.4
....................                      pass[i]=keypad; 
11EF:  MOVLW  37
11F0:  ADDWF  4F,W
11F1:  MOVWF  04
11F2:  BCF    03.7
11F3:  MOVF   35,W
11F4:  MOVWF  00
....................                      if(pass[i] == rightpass[i]) matchpass++;
11F5:  MOVLW  37
11F6:  ADDWF  4F,W
11F7:  MOVWF  04
11F8:  BCF    03.7
11F9:  MOVF   00,W
11FA:  MOVWF  67
11FB:  MOVLW  3C
11FC:  ADDWF  4F,W
11FD:  MOVWF  04
11FE:  BCF    03.7
11FF:  MOVF   00,W
1200:  SUBWF  67,W
1201:  BTFSS  03.2
1202:  GOTO   204
1203:  INCF   46,F
....................                      i++;
1204:  INCF   4F,F
....................                      delay_ms(300);
1205:  MOVLW  02
1206:  MOVWF  67
1207:  MOVLW  96
1208:  MOVWF  6A
1209:  BCF    0A.4
120A:  CALL   573
120B:  BSF    0A.4
120C:  DECFSZ 67,F
120D:  GOTO   207
....................                   }
120E:  GOTO   19F
....................                } 
....................                
....................                if (matchpass==5){
120F:  MOVF   46,W
1210:  SUBLW  05
1211:  BTFSS  03.2
1212:  GOTO   305
....................                   matchpass=0;
1213:  CLRF   46
....................                   checkpass= 1;  
1214:  MOVLW  01
1215:  MOVWF  34
....................                   lcd_putc('\f');
1216:  MOVLW  0C
1217:  MOVWF  6E
1218:  BCF    0A.4
1219:  CALL   273
121A:  BSF    0A.4
....................                   lcd_gotoxy(1,1);
121B:  MOVLW  01
121C:  MOVWF  6F
121D:  MOVWF  70
121E:  BCF    0A.4
121F:  CALL   250
1220:  BSF    0A.4
....................                   printf(lcd_putc, " ENTER NEW PASS ");
1221:  MOVLW  3D
1222:  BSF    03.6
1223:  MOVWF  0D
1224:  MOVLW  00
1225:  MOVWF  0F
1226:  BCF    0A.4
1227:  BCF    03.6
1228:  CALL   486
1229:  BSF    0A.4
....................                   delay_ms(500);
122A:  MOVLW  02
122B:  MOVWF  67
122C:  MOVLW  FA
122D:  MOVWF  6A
122E:  BCF    0A.4
122F:  CALL   573
1230:  BSF    0A.4
1231:  DECFSZ 67,F
1232:  GOTO   22C
....................                   lcd_gotoxy(6,2);
1233:  MOVLW  06
1234:  MOVWF  6F
1235:  MOVLW  02
1236:  MOVWF  70
1237:  BCF    0A.4
1238:  CALL   250
1239:  BSF    0A.4
....................                   int8 i=0;
123A:  CLRF   50
....................                   matchpass=0;
123B:  CLRF   46
....................                   while(i<5){
123C:  MOVF   50,W
123D:  SUBLW  04
123E:  BTFSS  03.0
123F:  GOTO   29A
....................                      key = scan();
1240:  BCF    0A.4
1241:  CALL   4DC
1242:  BSF    0A.4
1243:  MOVF   78,W
1244:  MOVWF  36
....................                      if(key){
1245:  MOVF   36,F
1246:  BTFSC  03.2
1247:  GOTO   299
....................                         keypad=phimnhan[key-1];
1248:  MOVLW  01
1249:  SUBWF  36,W
124A:  ADDLW  20
124B:  MOVWF  04
124C:  BCF    03.7
124D:  MOVF   00,W
124E:  MOVWF  35
....................                         if(keypad=='*'){
124F:  MOVF   35,W
1250:  SUBLW  2A
1251:  BTFSS  03.2
1252:  GOTO   26D
....................                            lcd_gotoxy(6,2); printf(lcd_putc,"          ");
1253:  MOVLW  06
1254:  MOVWF  6F
1255:  MOVLW  02
1256:  MOVWF  70
1257:  BCF    0A.4
1258:  CALL   250
1259:  BSF    0A.4
125A:  MOVLW  46
125B:  BSF    03.6
125C:  MOVWF  0D
125D:  MOVLW  00
125E:  MOVWF  0F
125F:  BCF    0A.4
1260:  BCF    03.6
1261:  CALL   486
1262:  BSF    0A.4
....................                            lcd_gotoxy(6,2); i=0; matchpass=0; 
1263:  MOVLW  06
1264:  MOVWF  6F
1265:  MOVLW  02
1266:  MOVWF  70
1267:  BCF    0A.4
1268:  CALL   250
1269:  BSF    0A.4
126A:  CLRF   50
126B:  CLRF   46
....................                            continue;//////////////////////////////////
126C:  GOTO   23C
....................                         }
....................                         printf(lcd_putc,"%c",keypad);
126D:  MOVF   35,W
126E:  MOVWF  6E
126F:  BCF    0A.4
1270:  CALL   273
1271:  BSF    0A.4
....................                         lcd_gotoxy(6+i,2); delay_ms(300);
1272:  MOVLW  06
1273:  ADDWF  50,W
1274:  MOVWF  67
1275:  MOVWF  6F
1276:  MOVLW  02
1277:  MOVWF  70
1278:  BCF    0A.4
1279:  CALL   250
127A:  BSF    0A.4
127B:  MOVLW  02
127C:  MOVWF  67
127D:  MOVLW  96
127E:  MOVWF  6A
127F:  BCF    0A.4
1280:  CALL   573
1281:  BSF    0A.4
1282:  DECFSZ 67,F
1283:  GOTO   27D
....................                         printf(lcd_putc,"*");
1284:  MOVLW  2A
1285:  MOVWF  6E
1286:  BCF    0A.4
1287:  CALL   273
1288:  BSF    0A.4
....................                         rightpass[i]=keypad; 
1289:  MOVLW  3C
128A:  ADDWF  50,W
128B:  MOVWF  04
128C:  BCF    03.7
128D:  MOVF   35,W
128E:  MOVWF  00
....................                         i++;
128F:  INCF   50,F
....................                         delay_ms(300);
1290:  MOVLW  02
1291:  MOVWF  67
1292:  MOVLW  96
1293:  MOVWF  6A
1294:  BCF    0A.4
1295:  CALL   573
1296:  BSF    0A.4
1297:  DECFSZ 67,F
1298:  GOTO   292
....................                      }
1299:  GOTO   23C
....................                   }
....................                   lcd_gotoxy(1,2);
129A:  MOVLW  01
129B:  MOVWF  6F
129C:  MOVLW  02
129D:  MOVWF  70
129E:  BCF    0A.4
129F:  CALL   250
12A0:  BSF    0A.4
....................                   printf(lcd_putc, "     DONE!      ");
12A1:  MOVLW  4C
12A2:  BSF    03.6
12A3:  MOVWF  0D
12A4:  MOVLW  00
12A5:  MOVWF  0F
12A6:  BCF    0A.4
12A7:  BCF    03.6
12A8:  CALL   486
12A9:  BSF    0A.4
....................                   delay_ms(1000);
12AA:  MOVLW  04
12AB:  MOVWF  67
12AC:  MOVLW  FA
12AD:  MOVWF  6A
12AE:  BCF    0A.4
12AF:  CALL   573
12B0:  BSF    0A.4
12B1:  DECFSZ 67,F
12B2:  GOTO   2AC
....................                   // ghi-doc eeprom
....................                   
....................                   unsigned int8 n;
....................                   for(n=0;n<5;n++){
12B3:  CLRF   51
12B4:  MOVF   51,W
12B5:  SUBLW  04
12B6:  BTFSS  03.0
12B7:  GOTO   2DC
....................                      write_eeprom(0x04+n,rightpass[n]); 
12B8:  MOVLW  04
12B9:  ADDWF  51,W
12BA:  MOVWF  67
12BB:  MOVLW  3C
12BC:  ADDWF  51,W
12BD:  MOVWF  04
12BE:  BCF    03.7
12BF:  MOVF   00,W
12C0:  MOVWF  68
12C1:  MOVF   0B,W
12C2:  MOVWF  77
12C3:  BCF    0B.7
12C4:  MOVF   67,W
12C5:  BSF    03.6
12C6:  MOVWF  0D
12C7:  BCF    03.6
12C8:  MOVF   68,W
12C9:  BSF    03.6
12CA:  MOVWF  0C
12CB:  BSF    03.5
12CC:  BCF    0C.7
12CD:  BSF    0C.2
12CE:  MOVLW  55
12CF:  MOVWF  0D
12D0:  MOVLW  AA
12D1:  MOVWF  0D
12D2:  BSF    0C.1
12D3:  BTFSC  0C.1
12D4:  GOTO   2D3
12D5:  BCF    0C.2
12D6:  MOVF   77,W
12D7:  BCF    03.5
12D8:  BCF    03.6
12D9:  IORWF  0B,F
12DA:  INCF   51,F
12DB:  GOTO   2B4
....................                   }  
....................                   eeprom_r_pass(0x04, rightpass);
12DC:  MOVLW  04
12DD:  MOVWF  72
12DE:  CLRF   74
12DF:  MOVLW  3C
12E0:  MOVWF  73
12E1:  BCF    0A.4
12E2:  CALL   46B
12E3:  BSF    0A.4
....................                   /////////////////////////////////////////
....................                   done=0;
12E4:  CLRF   4E
....................                   lcd_gotoxy(1,1);
12E5:  MOVLW  01
12E6:  MOVWF  6F
12E7:  MOVWF  70
12E8:  BCF    0A.4
12E9:  CALL   250
12EA:  BSF    0A.4
....................                   printf(lcd_putc,"  DOOR   LOCK   ");
12EB:  MOVLW  55
12EC:  BSF    03.6
12ED:  MOVWF  0D
12EE:  MOVLW  00
12EF:  MOVWF  0F
12F0:  BCF    0A.4
12F1:  BCF    03.6
12F2:  CALL   486
12F3:  BSF    0A.4
....................                   lcd_gotoxy(1,2);
12F4:  MOVLW  01
12F5:  MOVWF  6F
12F6:  MOVLW  02
12F7:  MOVWF  70
12F8:  BCF    0A.4
12F9:  CALL   250
12FA:  BSF    0A.4
....................                   printf(lcd_putc,"PRESS # TO HELP!");
12FB:  MOVLW  5E
12FC:  BSF    03.6
12FD:  MOVWF  0D
12FE:  MOVLW  00
12FF:  MOVWF  0F
1300:  BCF    0A.4
1301:  BCF    03.6
1302:  CALL   486
1303:  BSF    0A.4
....................                   
....................                   
....................                }
1304:  GOTO   358
....................                else if (matchpass==8) {
1305:  MOVF   46,W
1306:  SUBLW  08
1307:  BTFSS  03.2
1308:  GOTO   30D
....................                   keypad=0;
1309:  CLRF   35
....................                   key=0;
130A:  CLRF   36
....................                   break;
130B:  GOTO   359
....................                }
130C:  GOTO   358
....................                else {
....................                   matchpass=0;
130D:  CLRF   46
....................                   lcd_gotoxy(1,2);
130E:  MOVLW  01
130F:  MOVWF  6F
1310:  MOVLW  02
1311:  MOVWF  70
1312:  BCF    0A.4
1313:  CALL   250
1314:  BSF    0A.4
....................                   printf(lcd_putc,"   Incorrect!   "); delay_ms(1000);
1315:  MOVLW  67
1316:  BSF    03.6
1317:  MOVWF  0D
1318:  MOVLW  00
1319:  MOVWF  0F
131A:  BCF    0A.4
131B:  BCF    03.6
131C:  CALL   486
131D:  BSF    0A.4
131E:  MOVLW  04
131F:  MOVWF  67
1320:  MOVLW  FA
1321:  MOVWF  6A
1322:  BCF    0A.4
1323:  CALL   573
1324:  BSF    0A.4
1325:  DECFSZ 67,F
1326:  GOTO   320
....................                   lcd_gotoxy(1,2);
1327:  MOVLW  01
1328:  MOVWF  6F
1329:  MOVLW  02
132A:  MOVWF  70
132B:  BCF    0A.4
132C:  CALL   250
132D:  BSF    0A.4
....................                   printf(lcd_putc,"   Try again!   "); delay_ms(1000);
132E:  MOVLW  70
132F:  BSF    03.6
1330:  MOVWF  0D
1331:  MOVLW  00
1332:  MOVWF  0F
1333:  BCF    0A.4
1334:  BCF    03.6
1335:  CALL   486
1336:  BSF    0A.4
1337:  MOVLW  04
1338:  MOVWF  67
1339:  MOVLW  FA
133A:  MOVWF  6A
133B:  BCF    0A.4
133C:  CALL   573
133D:  BSF    0A.4
133E:  DECFSZ 67,F
133F:  GOTO   339
....................                   lcd_gotoxy(1,2);
1340:  MOVLW  01
1341:  MOVWF  6F
1342:  MOVLW  02
1343:  MOVWF  70
1344:  BCF    0A.4
1345:  CALL   250
1346:  BSF    0A.4
....................                   printf(lcd_putc,"                "); lcd_gotoxy(6,2);
1347:  MOVLW  79
1348:  BSF    03.6
1349:  MOVWF  0D
134A:  MOVLW  00
134B:  MOVWF  0F
134C:  BCF    0A.4
134D:  BCF    03.6
134E:  CALL   486
134F:  BSF    0A.4
1350:  MOVLW  06
1351:  MOVWF  6F
1352:  MOVLW  02
1353:  MOVWF  70
1354:  BCF    0A.4
1355:  CALL   250
1356:  BSF    0A.4
....................                   checkpass= 0;
1357:  CLRF   34
....................                }           
1358:  GOTO   176
....................             }
....................          }
....................          lockdoor();
1359:  BCF    0A.4
135A:  CALL   587
135B:  BSF    0A.4
....................         
.................... /*****************************************************************************/
....................          if(keypad == 'C'){
135C:  MOVF   35,W
135D:  SUBLW  43
135E:  BTFSS  03.2
135F:  GOTO   4A7
....................             matchpass=0;
1360:  CLRF   46
....................             while(matchpass!=8){
1361:  MOVF   46,W
1362:  SUBLW  08
1363:  BTFSC  03.2
1364:  GOTO   370
....................                enter_pass(); 
1365:  BCF    0A.4
1366:  BSF    0A.3
1367:  CALL   184
1368:  BSF    0A.4
1369:  BCF    0A.3
....................                if(matchpass==5) break;
136A:  MOVF   46,W
136B:  SUBLW  05
136C:  BTFSS  03.2
136D:  GOTO   36F
136E:  GOTO   370
136F:  GOTO   361
....................             }
....................             int8 done=1;
....................             char UID[6],i;
1370:  MOVLW  01
1371:  MOVWF  52
....................             //card_num =read_eeprom(card_num_add);
....................             while(done){
1372:  MOVF   52,F
1373:  BTFSC  03.2
1374:  GOTO   488
....................                key=scan();
1375:  BCF    0A.4
1376:  CALL   4DC
1377:  BSF    0A.4
1378:  MOVF   78,W
1379:  MOVWF  36
....................                if(key){
137A:  MOVF   36,F
137B:  BTFSC  03.2
137C:  GOTO   38B
....................                   keypad=phimnhan[key-1];
137D:  MOVLW  01
137E:  SUBWF  36,W
137F:  ADDLW  20
1380:  MOVWF  04
1381:  BCF    03.7
1382:  MOVF   00,W
1383:  MOVWF  35
....................                   if(keypad=='#'){
1384:  MOVF   35,W
1385:  SUBLW  23
1386:  BTFSS  03.2
1387:  GOTO   38B
....................                      key=0; keypad=0; 
1388:  CLRF   36
1389:  CLRF   35
....................                      break;
138A:  GOTO   488
....................                   }
....................                }
....................                lcd_putc('\c');
138B:  MOVLW  63
138C:  MOVWF  6E
138D:  BCF    0A.4
138E:  CALL   273
138F:  BSF    0A.4
....................                lcd_gotoxy(1,1);
1390:  MOVLW  01
1391:  MOVWF  6F
1392:  MOVWF  70
1393:  BCF    0A.4
1394:  CALL   250
1395:  BSF    0A.4
....................                printf(lcd_putc,"  ADD NEW CARD  ");
1396:  MOVLW  82
1397:  BSF    03.6
1398:  MOVWF  0D
1399:  MOVLW  00
139A:  MOVWF  0F
139B:  BCF    0A.4
139C:  BCF    03.6
139D:  CALL   486
139E:  BSF    0A.4
....................                lcd_gotoxy(1,2);
139F:  MOVLW  01
13A0:  MOVWF  6F
13A1:  MOVLW  02
13A2:  MOVWF  70
13A3:  BCF    0A.4
13A4:  CALL   250
13A5:  BSF    0A.4
....................                printf(lcd_putc,"  INSERT CARD!  ");
13A6:  MOVLW  8B
13A7:  BSF    03.6
13A8:  MOVWF  0D
13A9:  MOVLW  00
13AA:  MOVWF  0F
13AB:  BCF    0A.4
13AC:  BCF    03.6
13AD:  CALL   486
13AE:  BSF    0A.4
....................                
....................                if (MFRC522_isCard (&TagType)){             
13AF:  CLRF   72
13B0:  MOVLW  33
13B1:  MOVWF  71
13B2:  BCF    0A.4
13B3:  CALL   6A5
13B4:  BSF    0A.4
13B5:  MOVF   78,F
13B6:  BTFSC  03.2
13B7:  GOTO   487
....................                   if(MFRC522_ReadCardSerial (&UID)){
13B8:  CLRF   72
13B9:  MOVLW  53
13BA:  MOVWF  71
13BB:  BCF    0A.4
13BC:  CALL   6E2
13BD:  BSF    0A.4
13BE:  MOVF   78,F
13BF:  BTFSC  03.2
13C0:  GOTO   484
....................                      lcd_gotoxy(1,2);
13C1:  MOVLW  01
13C2:  MOVWF  6F
13C3:  MOVLW  02
13C4:  MOVWF  70
13C5:  BCF    0A.4
13C6:  CALL   250
13C7:  BSF    0A.4
....................                      printf(lcd_putc," ID: ");
13C8:  MOVLW  94
13C9:  BSF    03.6
13CA:  MOVWF  0D
13CB:  MOVLW  00
13CC:  MOVWF  0F
13CD:  BCF    0A.4
13CE:  BCF    03.6
13CF:  CALL   486
13D0:  BSF    0A.4
....................                      for(i=0;i<5;i++){
13D1:  CLRF   59
13D2:  MOVF   59,W
13D3:  SUBLW  04
13D4:  BTFSS  03.0
13D5:  GOTO   3E6
....................                         printf(lcd_putc,"%x",UID[i]);
13D6:  MOVLW  53
13D7:  ADDWF  59,W
13D8:  MOVWF  04
13D9:  BCF    03.7
13DA:  MOVF   00,W
13DB:  MOVWF  67
13DC:  MOVWF  68
13DD:  MOVLW  57
13DE:  MOVWF  69
13DF:  BCF    0A.4
13E0:  BSF    0A.3
13E1:  CALL   292
13E2:  BSF    0A.4
13E3:  BCF    0A.3
13E4:  INCF   59,F
13E5:  GOTO   3D2
....................                      }                 
....................                      delay_ms(1000);
13E6:  MOVLW  04
13E7:  MOVWF  67
13E8:  MOVLW  FA
13E9:  MOVWF  6A
13EA:  BCF    0A.4
13EB:  CALL   573
13EC:  BSF    0A.4
13ED:  DECFSZ 67,F
13EE:  GOTO   3E8
....................                      
....................                      done=0;
13EF:  CLRF   52
....................                      lcd_putc('\f');   lcd_gotoxy(1,1);
13F0:  MOVLW  0C
13F1:  MOVWF  6E
13F2:  BCF    0A.4
13F3:  CALL   273
13F4:  BSF    0A.4
13F5:  MOVLW  01
13F6:  MOVWF  6F
13F7:  MOVWF  70
13F8:  BCF    0A.4
13F9:  CALL   250
13FA:  BSF    0A.4
....................                      printf(lcd_putc," CHOOSE POSITON  ");
13FB:  MOVLW  97
13FC:  BSF    03.6
13FD:  MOVWF  0D
13FE:  MOVLW  00
13FF:  MOVWF  0F
1400:  BCF    0A.4
1401:  BCF    03.6
1402:  CALL   486
1403:  BSF    0A.4
....................                      lcd_gotoxy(1,2);
1404:  MOVLW  01
1405:  MOVWF  6F
1406:  MOVLW  02
1407:  MOVWF  70
1408:  BCF    0A.4
1409:  CALL   250
140A:  BSF    0A.4
....................                      printf(lcd_putc,"TO SAVE CARD:1-5");
140B:  MOVLW  A0
140C:  BSF    03.6
140D:  MOVWF  0D
140E:  MOVLW  00
140F:  MOVWF  0F
1410:  BCF    0A.4
1411:  BCF    03.6
1412:  CALL   486
1413:  BSF    0A.4
....................                      while(TRUE){
....................                         key=scan();
1414:  BCF    0A.4
1415:  CALL   4DC
1416:  BSF    0A.4
1417:  MOVF   78,W
1418:  MOVWF  36
....................                         if(key){
1419:  MOVF   36,F
141A:  BTFSC  03.2
141B:  GOTO   42F
....................                            keypad=phimnhan[key-1];
141C:  MOVLW  01
141D:  SUBWF  36,W
141E:  ADDLW  20
141F:  MOVWF  04
1420:  BCF    03.7
1421:  MOVF   00,W
1422:  MOVWF  35
....................                            if(keypad>='1' && keypad<='5'){
1423:  MOVF   35,W
1424:  SUBLW  30
1425:  BTFSC  03.0
1426:  GOTO   42F
1427:  MOVF   35,W
1428:  SUBLW  35
1429:  BTFSS  03.0
142A:  GOTO   42F
....................                               card_num=keypad-48;
142B:  MOVLW  30
142C:  SUBWF  35,W
142D:  MOVWF  48
....................                               break;
142E:  GOTO   430
....................                            }
....................                         }
142F:  GOTO   414
....................                      }
....................                      
....................                      lcd_clear();
1430:  BCF    0A.4
1431:  CALL   7F0
1432:  BSF    0A.4
....................                      lcd_gotoxy(1,1);
1433:  MOVLW  01
1434:  MOVWF  6F
1435:  MOVWF  70
1436:  BCF    0A.4
1437:  CALL   250
1438:  BSF    0A.4
....................                      printf(lcd_putc,"  ADD NEW CARD  ");
1439:  MOVLW  A9
143A:  BSF    03.6
143B:  MOVWF  0D
143C:  MOVLW  00
143D:  MOVWF  0F
143E:  BCF    0A.4
143F:  BCF    03.6
1440:  CALL   486
1441:  BSF    0A.4
....................                      lcd_gotoxy(1,2);
1442:  MOVLW  01
1443:  MOVWF  6F
1444:  MOVLW  02
1445:  MOVWF  70
1446:  BCF    0A.4
1447:  CALL   250
1448:  BSF    0A.4
....................                      printf(lcd_putc,"     DONE!      "); 
1449:  MOVLW  B2
144A:  BSF    03.6
144B:  MOVWF  0D
144C:  MOVLW  00
144D:  MOVWF  0F
144E:  BCF    0A.4
144F:  BCF    03.6
1450:  CALL   486
1451:  BSF    0A.4
....................                      delay_ms(1000);
1452:  MOVLW  04
1453:  MOVWF  67
1454:  MOVLW  FA
1455:  MOVWF  6A
1456:  BCF    0A.4
1457:  CALL   573
1458:  BSF    0A.4
1459:  DECFSZ 67,F
145A:  GOTO   454
....................                      
....................                      eeprom_w_pass(card_add +16*card_num, UID);
145B:  SWAPF  48,W
145C:  MOVWF  77
145D:  MOVLW  F0
145E:  ANDWF  77,F
145F:  MOVF   77,W
1460:  ADDLW  24
1461:  MOVWF  67
1462:  MOVWF  68
1463:  CLRF   6A
1464:  MOVLW  53
1465:  MOVWF  69
1466:  BCF    0A.4
1467:  BSF    0A.3
1468:  CALL   2B7
1469:  BSF    0A.4
146A:  BCF    0A.3
....................                      //card_num++;
....................                      write_eeprom(card_num_add, card_num);
146B:  MOVF   0B,W
146C:  MOVWF  77
146D:  BCF    0B.7
146E:  MOVLW  14
146F:  BSF    03.6
1470:  MOVWF  0D
1471:  BCF    03.6
1472:  MOVF   48,W
1473:  BSF    03.6
1474:  MOVWF  0C
1475:  BSF    03.5
1476:  BCF    0C.7
1477:  BSF    0C.2
1478:  MOVLW  55
1479:  MOVWF  0D
147A:  MOVLW  AA
147B:  MOVWF  0D
147C:  BSF    0C.1
147D:  BTFSC  0C.1
147E:  GOTO   47D
147F:  BCF    0C.2
1480:  MOVF   77,W
1481:  BCF    03.5
1482:  BCF    03.6
1483:  IORWF  0B,F
.................... //!                     eeprom_r_pass(card_add+16*(card_num-1),rightid);
.................... //!                     lcd_clear();
.................... //!                     for(i=0;i<5;i++){
.................... //!                        printf(lcd_putc,"%x",rightid[i]);
.................... //!                     }
.................... //!                     delay_ms(2000);
....................                   }
....................                      MFRC522_Halt() ;           
1484:  BCF    0A.4
1485:  CALL   749
1486:  BSF    0A.4
....................                }        
1487:  GOTO   372
....................                
....................             }
....................             lcd_gotoxy(1,1);
1488:  MOVLW  01
1489:  MOVWF  6F
148A:  MOVWF  70
148B:  BCF    0A.4
148C:  CALL   250
148D:  BSF    0A.4
....................             printf(lcd_putc,"  DOOR   LOCK   ");
148E:  MOVLW  BB
148F:  BSF    03.6
1490:  MOVWF  0D
1491:  MOVLW  00
1492:  MOVWF  0F
1493:  BCF    0A.4
1494:  BCF    03.6
1495:  CALL   486
1496:  BSF    0A.4
....................             lcd_gotoxy(1,2);
1497:  MOVLW  01
1498:  MOVWF  6F
1499:  MOVLW  02
149A:  MOVWF  70
149B:  BCF    0A.4
149C:  CALL   250
149D:  BSF    0A.4
....................             printf(lcd_putc,"PRESS # TO HELP!");   
149E:  MOVLW  C4
149F:  BSF    03.6
14A0:  MOVWF  0D
14A1:  MOVLW  00
14A2:  MOVWF  0F
14A3:  BCF    0A.4
14A4:  BCF    03.6
14A5:  CALL   486
14A6:  BSF    0A.4
....................             
....................          }
....................          lockdoor();
14A7:  BCF    0A.4
14A8:  CALL   587
14A9:  BSF    0A.4
....................         
.................... /*****************************************************************************/         
....................          if(keypad == 'D'){
14AA:  MOVF   35,W
14AB:  SUBLW  44
14AC:  BTFSS  03.2
14AD:  GOTO   5F0
....................             matchpass=0;
14AE:  CLRF   46
....................             while(matchpass!=8){
14AF:  MOVF   46,W
14B0:  SUBLW  08
14B1:  BTFSC  03.2
14B2:  GOTO   4BE
....................                enter_pass(); 
14B3:  BCF    0A.4
14B4:  BSF    0A.3
14B5:  CALL   184
14B6:  BSF    0A.4
14B7:  BCF    0A.3
....................                if(matchpass==5) break;
14B8:  MOVF   46,W
14B9:  SUBLW  05
14BA:  BTFSS  03.2
14BB:  GOTO   4BD
14BC:  GOTO   4BE
14BD:  GOTO   4AF
....................             }
....................             int8 done =1;
14BE:  MOVLW  01
14BF:  MOVWF  5A
....................             while(done){   
14C0:  MOVF   5A,F
14C1:  BTFSC  03.2
14C2:  GOTO   5F0
....................                lcd_clear(); key=0;
14C3:  BCF    0A.4
14C4:  CALL   7F0
14C5:  BSF    0A.4
14C6:  CLRF   36
....................                lcd_gotoxy(1,1); 
14C7:  MOVLW  01
14C8:  MOVWF  6F
14C9:  MOVWF  70
14CA:  BCF    0A.4
14CB:  CALL   250
14CC:  BSF    0A.4
....................                printf(lcd_putc,"  REMOVE CARD!  ");
14CD:  MOVLW  CD
14CE:  BSF    03.6
14CF:  MOVWF  0D
14D0:  MOVLW  00
14D1:  MOVWF  0F
14D2:  BCF    0A.4
14D3:  BCF    03.6
14D4:  CALL   486
14D5:  BSF    0A.4
....................                lcd_gotoxy(1,2);
14D6:  MOVLW  01
14D7:  MOVWF  6F
14D8:  MOVLW  02
14D9:  MOVWF  70
14DA:  BCF    0A.4
14DB:  CALL   250
14DC:  BSF    0A.4
....................                printf(lcd_putc,"CHOOSE CARD: 1-5");
14DD:  MOVLW  D6
14DE:  BSF    03.6
14DF:  MOVWF  0D
14E0:  MOVLW  00
14E1:  MOVWF  0F
14E2:  BCF    0A.4
14E3:  BCF    03.6
14E4:  CALL   486
14E5:  BSF    0A.4
....................                delay_ms(500);
14E6:  MOVLW  02
14E7:  MOVWF  67
14E8:  MOVLW  FA
14E9:  MOVWF  6A
14EA:  BCF    0A.4
14EB:  CALL   573
14EC:  BSF    0A.4
14ED:  DECFSZ 67,F
14EE:  GOTO   4E8
....................                key=0; keypad=0;
14EF:  CLRF   36
14F0:  CLRF   35
....................                
....................                while(done){
14F1:  MOVF   5A,F
14F2:  BTFSC  03.2
14F3:  GOTO   5D5
....................                   int8 key_del=0;
....................                   int8 UID[5], z;
14F4:  CLRF   5B
....................                   if(key){
14F5:  MOVF   36,F
14F6:  BTFSC  03.2
14F7:  GOTO   571
....................                      keypad=phimnhan[key-1];
14F8:  MOVLW  01
14F9:  SUBWF  36,W
14FA:  ADDLW  20
14FB:  MOVWF  04
14FC:  BCF    03.7
14FD:  MOVF   00,W
14FE:  MOVWF  35
....................                      lcd_putc('\f');   lcd_gotoxy(1,1);
14FF:  MOVLW  0C
1500:  MOVWF  6E
1501:  BCF    0A.4
1502:  CALL   273
1503:  BSF    0A.4
1504:  MOVLW  01
1505:  MOVWF  6F
1506:  MOVWF  70
1507:  BCF    0A.4
1508:  CALL   250
1509:  BSF    0A.4
....................                      printf(lcd_putc,"     CARD %d     ",keypad-48);
150A:  MOVLW  30
150B:  SUBWF  35,W
150C:  MOVWF  67
150D:  MOVLW  DF
150E:  BSF    03.6
150F:  MOVWF  0D
1510:  MOVLW  00
1511:  MOVWF  0F
1512:  BCF    03.0
1513:  MOVLW  0A
1514:  BCF    03.6
1515:  MOVWF  68
1516:  BCF    0A.4
1517:  BSF    0A.3
1518:  CALL   2E9
1519:  BSF    0A.4
151A:  BCF    0A.3
151B:  MOVF   67,W
151C:  MOVWF  68
151D:  MOVLW  18
151E:  MOVWF  69
151F:  BCF    0A.4
1520:  BSF    0A.3
1521:  GOTO   344
1522:  BSF    0A.4
1523:  BCF    0A.3
1524:  MOVLW  E5
1525:  BSF    03.6
1526:  MOVWF  0D
1527:  MOVLW  00
1528:  MOVWF  0F
1529:  BCF    03.0
152A:  MOVLW  05
152B:  BCF    03.6
152C:  MOVWF  68
152D:  BCF    0A.4
152E:  BSF    0A.3
152F:  CALL   2E9
1530:  BSF    0A.4
1531:  BCF    0A.3
....................                      lcd_gotoxy(1,2);  printf(lcd_putc," ID: ");
1532:  MOVLW  01
1533:  MOVWF  6F
1534:  MOVLW  02
1535:  MOVWF  70
1536:  BCF    0A.4
1537:  CALL   250
1538:  BSF    0A.4
1539:  MOVLW  E8
153A:  BSF    03.6
153B:  MOVWF  0D
153C:  MOVLW  00
153D:  MOVWF  0F
153E:  BCF    0A.4
153F:  BCF    03.6
1540:  CALL   486
1541:  BSF    0A.4
....................                      eeprom_r_pass(card_add +16*(keypad-48), UID);
1542:  MOVLW  30
1543:  SUBWF  35,W
1544:  MOVWF  77
1545:  SWAPF  77,F
1546:  MOVLW  F0
1547:  ANDWF  77,F
1548:  MOVF   77,W
1549:  ADDLW  24
154A:  MOVWF  67
154B:  MOVWF  72
154C:  CLRF   74
154D:  MOVLW  5C
154E:  MOVWF  73
154F:  BCF    0A.4
1550:  CALL   46B
1551:  BSF    0A.4
....................                      lcd_gotoxy(6,2);
1552:  MOVLW  06
1553:  MOVWF  6F
1554:  MOVLW  02
1555:  MOVWF  70
1556:  BCF    0A.4
1557:  CALL   250
1558:  BSF    0A.4
....................                      for(z=0;z<5;z++){
1559:  CLRF   61
155A:  MOVF   61,W
155B:  SUBLW  04
155C:  BTFSS  03.0
155D:  GOTO   56E
....................                         printf(lcd_putc,"%x",UID[z]);
155E:  MOVLW  5C
155F:  ADDWF  61,W
1560:  MOVWF  04
1561:  BCF    03.7
1562:  MOVF   00,W
1563:  MOVWF  67
1564:  MOVWF  68
1565:  MOVLW  57
1566:  MOVWF  69
1567:  BCF    0A.4
1568:  BSF    0A.3
1569:  CALL   292
156A:  BSF    0A.4
156B:  BCF    0A.3
156C:  INCF   61,F
156D:  GOTO   55A
....................                      }
....................                      key_del = keypad -48;
156E:  MOVLW  30
156F:  SUBWF  35,W
1570:  MOVWF  5B
....................                   }
....................                   while(TRUE){
....................                      
....................                      key=scan();
1571:  BCF    0A.4
1572:  CALL   4DC
1573:  BSF    0A.4
1574:  MOVF   78,W
1575:  MOVWF  36
....................                      delay_ms(200);
1576:  MOVLW  C8
1577:  MOVWF  6A
1578:  BCF    0A.4
1579:  CALL   573
157A:  BSF    0A.4
....................                      if(key) {
157B:  MOVF   36,F
157C:  BTFSC  03.2
157D:  GOTO   5D3
....................                         //key_del = keypad;
....................                         keypad=phimnhan[key-1];
157E:  MOVLW  01
157F:  SUBWF  36,W
1580:  ADDLW  20
1581:  MOVWF  04
1582:  BCF    03.7
1583:  MOVF   00,W
1584:  MOVWF  35
....................                         
....................                         if(keypad == '#') {
1585:  MOVF   35,W
1586:  SUBLW  23
1587:  BTFSS  03.2
1588:  GOTO   58B
....................                            done=0;
1589:  CLRF   5A
....................                            break;
158A:  GOTO   5D4
....................                         }
....................                         
....................                         if(keypad == '*' && key_del){
158B:  MOVF   35,W
158C:  SUBLW  2A
158D:  BTFSS  03.2
158E:  GOTO   5C7
158F:  MOVF   5B,F
1590:  BTFSC  03.2
1591:  GOTO   5C7
....................                            int8 UID_del[5]={0xff,0xff,0xff,0xff,0xff};
1592:  MOVLW  FF
1593:  MOVWF  62
1594:  MOVWF  63
1595:  MOVWF  64
1596:  MOVWF  65
1597:  MOVWF  66
....................                            eeprom_w_pass(card_add+ 16*(key_del),UID_del);
1598:  SWAPF  5B,W
1599:  MOVWF  77
159A:  MOVLW  F0
159B:  ANDWF  77,F
159C:  MOVF   77,W
159D:  ADDLW  24
159E:  MOVWF  67
159F:  MOVWF  68
15A0:  CLRF   6A
15A1:  MOVLW  62
15A2:  MOVWF  69
15A3:  BCF    0A.4
15A4:  BSF    0A.3
15A5:  CALL   2B7
15A6:  BSF    0A.4
15A7:  BCF    0A.3
....................                            keypad=key_del+48;
15A8:  MOVLW  30
15A9:  ADDWF  5B,W
15AA:  MOVWF  35
....................                            lcd_gotoxy(1,2); printf(lcd_putc,"    DELETED!    ");
15AB:  MOVLW  01
15AC:  MOVWF  6F
15AD:  MOVLW  02
15AE:  MOVWF  70
15AF:  BCF    0A.4
15B0:  CALL   250
15B1:  BSF    0A.4
15B2:  MOVLW  EB
15B3:  BSF    03.6
15B4:  MOVWF  0D
15B5:  MOVLW  00
15B6:  MOVWF  0F
15B7:  BCF    0A.4
15B8:  BCF    03.6
15B9:  CALL   486
15BA:  BSF    0A.4
....................                            delay_ms(1000);
15BB:  MOVLW  04
15BC:  MOVWF  67
15BD:  MOVLW  FA
15BE:  MOVWF  6A
15BF:  BCF    0A.4
15C0:  CALL   573
15C1:  BSF    0A.4
15C2:  DECFSZ 67,F
15C3:  GOTO   5BD
....................                            key=0; done=0;
15C4:  CLRF   36
15C5:  CLRF   5A
....................                            break;
15C6:  GOTO   5D4
....................                         }
....................                         
....................                         if(keypad >='1' && keypad <='5') {
15C7:  MOVF   35,W
15C8:  SUBLW  30
15C9:  BTFSC  03.0
15CA:  GOTO   5D3
15CB:  MOVF   35,W
15CC:  SUBLW  35
15CD:  BTFSS  03.0
15CE:  GOTO   5D3
....................                            key_del=keypad-48;
15CF:  MOVLW  30
15D0:  SUBWF  35,W
15D1:  MOVWF  5B
....................                            break;
15D2:  GOTO   5D4
....................                         }
....................                      }
15D3:  GOTO   571
....................                   }
15D4:  GOTO   4F1
....................                }
....................     
....................                delay_ms(200);
15D5:  MOVLW  C8
15D6:  MOVWF  6A
15D7:  BCF    0A.4
15D8:  CALL   573
15D9:  BSF    0A.4
....................                key=scan();
15DA:  BCF    0A.4
15DB:  CALL   4DC
15DC:  BSF    0A.4
15DD:  MOVF   78,W
15DE:  MOVWF  36
....................                if(key){
15DF:  MOVF   36,F
15E0:  BTFSC  03.2
15E1:  GOTO   5EF
....................                   keypad=phimnhan[key-1];
15E2:  MOVLW  01
15E3:  SUBWF  36,W
15E4:  ADDLW  20
15E5:  MOVWF  04
15E6:  BCF    03.7
15E7:  MOVF   00,W
15E8:  MOVWF  35
....................                   if(keypad=='#'){
15E9:  MOVF   35,W
15EA:  SUBLW  23
15EB:  BTFSS  03.2
15EC:  GOTO   5EF
....................                      keypad=0;
15ED:  CLRF   35
....................                      break;
15EE:  GOTO   5F0
....................                   } 
....................                }
15EF:  GOTO   4C0
....................             }
....................          }
....................          lockdoor();
15F0:  BCF    0A.4
15F1:  CALL   587
15F2:  BSF    0A.4
....................         
.................... /*****************************************************************************/          
....................       }
....................       keypad=0; key=0;
15F3:  CLRF   35
15F4:  CLRF   36
15F5:  GOTO   12B
....................    }
.................... 
.................... }
.................... 
15F6:  SLEEP
.................... void _CaiDatLCD(void)
.................... {
....................    lcd_init();//khoi dong module LCD
....................    lcd_putc('\f');//xoa trang man hinh LCD
*
02CE:  MOVLW  0C
02CF:  MOVWF  6E
02D0:  CALL   273
02D1:  BCF    0A.3
02D2:  BSF    0A.4
02D3:  GOTO   03C (RETURN)
.................... }
.................... 
.................... void lcd_clear(){
....................    lcd_putc('\f');
*
07F0:  MOVLW  0C
07F1:  MOVWF  6E
07F2:  CALL   273
07F3:  RETURN
.................... }
.................... 
.................... void clear_UID(){
.................... 
....................    int8 i;
....................    for(i=0;i<5;i++){
....................       key_UID[i]=0x00;
....................    }
.................... }
.................... 
.................... unsigned int8 *card_id(){
....................    unsigned int8 UID[5];
....................    unsigned int8 TagType; 
....................    if (MFRC522_isCard (&TagType)) //Check any card
....................        {             
....................         if(MFRC522_ReadCardSerial (&UID)) 
....................         {
....................             return UID;                    
....................         }        
....................         MFRC522_Halt() ; 
....................     }
....................     else return 0;
....................     
.................... }
.................... 
.................... void lockdoor(){
....................    
....................    output_high(pin_A1); // led do sang
*
0587:  BSF    03.5
0588:  BCF    05.1
0589:  BCF    03.5
058A:  BSF    05.1
....................    output_low(pin_A0);  // led xanh tat
058B:  BSF    03.5
058C:  BCF    05.0
058D:  BCF    03.5
058E:  BCF    05.0
....................    lcd_gotoxy(1,1);
058F:  MOVLW  01
0590:  MOVWF  6F
0591:  MOVWF  70
0592:  CALL   250
....................    printf(lcd_putc,"  DOOR   LOCK   ");
0593:  MOVLW  F4
0594:  BSF    03.6
0595:  MOVWF  0D
0596:  MOVLW  00
0597:  MOVWF  0F
0598:  BCF    03.6
0599:  CALL   486
....................    lcd_gotoxy(1,2);
059A:  MOVLW  01
059B:  MOVWF  6F
059C:  MOVLW  02
059D:  MOVWF  70
059E:  CALL   250
....................    printf(lcd_putc,"PRESS # TO HELP!");
059F:  MOVLW  FD
05A0:  BSF    03.6
05A1:  MOVWF  0D
05A2:  MOVLW  00
05A3:  MOVWF  0F
05A4:  BCF    03.6
05A5:  CALL   486
05A6:  RETURN
....................   
.................... }
.................... 
.................... void unlockdoor(){
....................    
....................    output_low(pin_A1);   // den do tat
*
0852:  BSF    03.5
0853:  BCF    05.1
0854:  BCF    03.5
0855:  BCF    05.1
....................    output_high(pin_A0);  // den xanh sang
0856:  BSF    03.5
0857:  BCF    05.0
0858:  BCF    03.5
0859:  BSF    05.0
....................    lcd_gotoxy(1,1);
085A:  MOVLW  01
085B:  MOVWF  6F
085C:  MOVWF  70
085D:  BCF    0A.3
085E:  CALL   250
085F:  BSF    0A.3
....................    printf(lcd_putc,"  DOOR  UNLOCK  ");
0860:  MOVLW  06
0861:  BSF    03.6
0862:  MOVWF  0D
0863:  MOVLW  01
0864:  MOVWF  0F
0865:  BCF    0A.3
0866:  BCF    03.6
0867:  CALL   486
0868:  BSF    0A.3
....................    lcd_gotoxy(1,2);
0869:  MOVLW  01
086A:  MOVWF  6F
086B:  MOVLW  02
086C:  MOVWF  70
086D:  BCF    0A.3
086E:  CALL   250
086F:  BSF    0A.3
....................    printf(lcd_putc,"PRESS # TO HELP!");
0870:  MOVLW  0F
0871:  BSF    03.6
0872:  MOVWF  0D
0873:  MOVLW  01
0874:  MOVWF  0F
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   486
0878:  BSF    0A.3
....................   
....................    output_low(pin_A2);   /// motor quay thuan 
0879:  BSF    03.5
087A:  BCF    05.2
087B:  BCF    03.5
087C:  BCF    05.2
....................    output_high(pin_A3);
087D:  BSF    03.5
087E:  BCF    05.3
087F:  BCF    03.5
0880:  BSF    05.3
....................    delay_ms(1500);       // quay 1,5 giay
0881:  MOVLW  06
0882:  MOVWF  69
0883:  MOVLW  FA
0884:  MOVWF  6A
0885:  BCF    0A.3
0886:  CALL   573
0887:  BSF    0A.3
0888:  DECFSZ 69,F
0889:  GOTO   083
....................    output_low(pin_A2);   // dung motor
088A:  BSF    03.5
088B:  BCF    05.2
088C:  BCF    03.5
088D:  BCF    05.2
....................    output_low(pin_A3);
088E:  BSF    03.5
088F:  BCF    05.3
0890:  BCF    03.5
0891:  BCF    05.3
....................    
....................     delay_ms(3500);       // cho them 3,5 giay
0892:  MOVLW  0E
0893:  MOVWF  69
0894:  MOVLW  FA
0895:  MOVWF  6A
0896:  BCF    0A.3
0897:  CALL   573
0898:  BSF    0A.3
0899:  DECFSZ 69,F
089A:  GOTO   094
.................... 
.................... 
....................    lockdoor();          // den xanh tat, den do sang, khoa cua
089B:  BCF    0A.3
089C:  CALL   587
089D:  BSF    0A.3
....................    
....................    output_low(pin_A3);   /// motor quay nghich
089E:  BSF    03.5
089F:  BCF    05.3
08A0:  BCF    03.5
08A1:  BCF    05.3
....................    output_high(pin_A2);  //
08A2:  BSF    03.5
08A3:  BCF    05.2
08A4:  BCF    03.5
08A5:  BSF    05.2
....................    delay_ms(1500);      // quay 1,5 giay
08A6:  MOVLW  06
08A7:  MOVWF  69
08A8:  MOVLW  FA
08A9:  MOVWF  6A
08AA:  BCF    0A.3
08AB:  CALL   573
08AC:  BSF    0A.3
08AD:  DECFSZ 69,F
08AE:  GOTO   0A8
....................    output_low(pin_A2);   // dung motor
08AF:  BSF    03.5
08B0:  BCF    05.2
08B1:  BCF    03.5
08B2:  BCF    05.2
....................    output_low(pin_A3);
08B3:  BSF    03.5
08B4:  BCF    05.3
08B5:  BCF    03.5
08B6:  BCF    05.3
08B7:  RETURN
.................... }
.................... 
.................... void enter_pass(){
....................    lcd_putc('\f');
*
0984:  MOVLW  0C
0985:  MOVWF  6E
0986:  BCF    0A.3
0987:  CALL   273
0988:  BSF    0A.3
....................    lcd_gotoxy(1,1);
0989:  MOVLW  01
098A:  MOVWF  6F
098B:  MOVWF  70
098C:  BCF    0A.3
098D:  CALL   250
098E:  BSF    0A.3
....................    printf(lcd_putc, " ENTER PASSWORD");
098F:  MOVLW  18
0990:  BSF    03.6
0991:  MOVWF  0D
0992:  MOVLW  01
0993:  MOVWF  0F
0994:  BCF    0A.3
0995:  BCF    03.6
0996:  CALL   486
0997:  BSF    0A.3
....................    delay_ms(500);
0998:  MOVLW  02
0999:  MOVWF  68
099A:  MOVLW  FA
099B:  MOVWF  6A
099C:  BCF    0A.3
099D:  CALL   573
099E:  BSF    0A.3
099F:  DECFSZ 68,F
09A0:  GOTO   19A
....................    lcd_gotoxy(6,2);
09A1:  MOVLW  06
09A2:  MOVWF  6F
09A3:  MOVLW  02
09A4:  MOVWF  70
09A5:  BCF    0A.3
09A6:  CALL   250
09A7:  BSF    0A.3
....................    int8 i=0;
09A8:  CLRF   67
....................    matchpass=0;
09A9:  CLRF   46
....................    while(i<5){
09AA:  MOVF   67,W
09AB:  SUBLW  04
09AC:  BTFSS  03.0
09AD:  GOTO   223
....................       
....................       scan_card();
09AE:  CALL   000
....................       check_card();
09AF:  CALL   0B8
....................       if(matchpass==7) break;
09B0:  MOVF   46,W
09B1:  SUBLW  07
09B2:  BTFSC  03.2
09B3:  GOTO   223
....................       key = scan();
09B4:  BCF    0A.3
09B5:  CALL   4DC
09B6:  BSF    0A.3
09B7:  MOVF   78,W
09B8:  MOVWF  36
....................       if(key){
09B9:  MOVF   36,F
09BA:  BTFSC  03.2
09BB:  GOTO   222
....................          keypad=phimnhan[key-1];
09BC:  MOVLW  01
09BD:  SUBWF  36,W
09BE:  ADDLW  20
09BF:  MOVWF  04
09C0:  BCF    03.7
09C1:  MOVF   00,W
09C2:  MOVWF  35
....................          if(keypad=='#'){
09C3:  MOVF   35,W
09C4:  SUBLW  23
09C5:  BTFSS  03.2
09C6:  GOTO   1CA
....................             matchpass = 8;   
09C7:  MOVLW  08
09C8:  MOVWF  46
....................             break;
09C9:  GOTO   223
....................          } ///////////////////////////////////////////////
....................          if(keypad=='*'){
09CA:  MOVF   35,W
09CB:  SUBLW  2A
09CC:  BTFSS  03.2
09CD:  GOTO   1E8
....................             lcd_gotoxy(6,2); printf(lcd_putc,"          ");
09CE:  MOVLW  06
09CF:  MOVWF  6F
09D0:  MOVLW  02
09D1:  MOVWF  70
09D2:  BCF    0A.3
09D3:  CALL   250
09D4:  BSF    0A.3
09D5:  MOVLW  20
09D6:  BSF    03.6
09D7:  MOVWF  0D
09D8:  MOVLW  01
09D9:  MOVWF  0F
09DA:  BCF    0A.3
09DB:  BCF    03.6
09DC:  CALL   486
09DD:  BSF    0A.3
....................             lcd_gotoxy(6,2); i=0; matchpass=0; 
09DE:  MOVLW  06
09DF:  MOVWF  6F
09E0:  MOVLW  02
09E1:  MOVWF  70
09E2:  BCF    0A.3
09E3:  CALL   250
09E4:  BSF    0A.3
09E5:  CLRF   67
09E6:  CLRF   46
....................             continue;//////////////////////////////////
09E7:  GOTO   1AA
....................          }
....................          printf(lcd_putc,"%c",keypad);
09E8:  MOVF   35,W
09E9:  MOVWF  6E
09EA:  BCF    0A.3
09EB:  CALL   273
09EC:  BSF    0A.3
....................          lcd_gotoxy(6+i,2); delay_ms(300);
09ED:  MOVLW  06
09EE:  ADDWF  67,W
09EF:  MOVWF  68
09F0:  MOVWF  6F
09F1:  MOVLW  02
09F2:  MOVWF  70
09F3:  BCF    0A.3
09F4:  CALL   250
09F5:  BSF    0A.3
09F6:  MOVLW  02
09F7:  MOVWF  68
09F8:  MOVLW  96
09F9:  MOVWF  6A
09FA:  BCF    0A.3
09FB:  CALL   573
09FC:  BSF    0A.3
09FD:  DECFSZ 68,F
09FE:  GOTO   1F8
....................          printf(lcd_putc,"*");
09FF:  MOVLW  2A
0A00:  MOVWF  6E
0A01:  BCF    0A.3
0A02:  CALL   273
0A03:  BSF    0A.3
....................          pass[i]=keypad; 
0A04:  MOVLW  37
0A05:  ADDWF  67,W
0A06:  MOVWF  04
0A07:  BCF    03.7
0A08:  MOVF   35,W
0A09:  MOVWF  00
....................          if(pass[i] == rightpass[i]) matchpass++;
0A0A:  MOVLW  37
0A0B:  ADDWF  67,W
0A0C:  MOVWF  04
0A0D:  BCF    03.7
0A0E:  MOVF   00,W
0A0F:  MOVWF  68
0A10:  MOVLW  3C
0A11:  ADDWF  67,W
0A12:  MOVWF  04
0A13:  BCF    03.7
0A14:  MOVF   00,W
0A15:  SUBWF  68,W
0A16:  BTFSC  03.2
0A17:  INCF   46,F
....................          i++;
0A18:  INCF   67,F
....................          delay_ms(300);
0A19:  MOVLW  02
0A1A:  MOVWF  68
0A1B:  MOVLW  96
0A1C:  MOVWF  6A
0A1D:  BCF    0A.3
0A1E:  CALL   573
0A1F:  BSF    0A.3
0A20:  DECFSZ 68,F
0A21:  GOTO   21B
....................       }
0A22:  GOTO   1AA
....................    }  
0A23:  RETURN
.................... }
.................... 
.................... void check_pass(char *c){
....................    if (matchpass==5){
0A24:  MOVF   46,W
0A25:  SUBLW  05
0A26:  BTFSS  03.2
0A27:  GOTO   22D
....................       matchpass=0;
0A28:  CLRF   46
....................       unlockdoor();
0A29:  CALL   052
....................       checkpass= 1;  
0A2A:  MOVLW  01
0A2B:  MOVWF  34
....................    }
0A2C:  GOTO   28F
....................    else if (matchpass==7){
0A2D:  MOVF   46,W
0A2E:  SUBLW  07
0A2F:  BTFSS  03.2
0A30:  GOTO   236
....................       matchpass=0;
0A31:  CLRF   46
....................       matchcard=0;
0A32:  CLRF   47
....................       checkpass= 1;
0A33:  MOVLW  01
0A34:  MOVWF  34
....................       break;
....................    }
0A35:  GOTO   28F
....................    else if (matchpass ==8){
0A36:  MOVF   46,W
0A37:  SUBLW  08
0A38:  BTFSS  03.2
0A39:  GOTO   241
....................       matchpass=0;
0A3A:  CLRF   46
....................       matchcard=0;
0A3B:  CLRF   47
....................       checkpass= 1;
0A3C:  MOVLW  01
0A3D:  MOVWF  34
....................       key=0;
0A3E:  CLRF   36
....................       keypad=0;
0A3F:  CLRF   35
....................       break;  
....................    }
0A40:  GOTO   28F
....................    else {
....................       matchpass=0;
0A41:  CLRF   46
....................       lockdoor();
0A42:  BCF    0A.3
0A43:  CALL   587
0A44:  BSF    0A.3
....................       lcd_gotoxy(1,2);
0A45:  MOVLW  01
0A46:  MOVWF  6F
0A47:  MOVLW  02
0A48:  MOVWF  70
0A49:  BCF    0A.3
0A4A:  CALL   250
0A4B:  BSF    0A.3
....................       printf(lcd_putc,"   Incorrect!   "); delay_ms(1000);
0A4C:  MOVLW  26
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  01
0A50:  MOVWF  0F
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   486
0A54:  BSF    0A.3
0A55:  MOVLW  04
0A56:  MOVWF  69
0A57:  MOVLW  FA
0A58:  MOVWF  6A
0A59:  BCF    0A.3
0A5A:  CALL   573
0A5B:  BSF    0A.3
0A5C:  DECFSZ 69,F
0A5D:  GOTO   257
....................       lcd_gotoxy(1,2);
0A5E:  MOVLW  01
0A5F:  MOVWF  6F
0A60:  MOVLW  02
0A61:  MOVWF  70
0A62:  BCF    0A.3
0A63:  CALL   250
0A64:  BSF    0A.3
....................       printf(lcd_putc,"   Try again!   "); delay_ms(1000);
0A65:  MOVLW  2F
0A66:  BSF    03.6
0A67:  MOVWF  0D
0A68:  MOVLW  01
0A69:  MOVWF  0F
0A6A:  BCF    0A.3
0A6B:  BCF    03.6
0A6C:  CALL   486
0A6D:  BSF    0A.3
0A6E:  MOVLW  04
0A6F:  MOVWF  69
0A70:  MOVLW  FA
0A71:  MOVWF  6A
0A72:  BCF    0A.3
0A73:  CALL   573
0A74:  BSF    0A.3
0A75:  DECFSZ 69,F
0A76:  GOTO   270
....................       lcd_gotoxy(1,2);
0A77:  MOVLW  01
0A78:  MOVWF  6F
0A79:  MOVLW  02
0A7A:  MOVWF  70
0A7B:  BCF    0A.3
0A7C:  CALL   250
0A7D:  BSF    0A.3
....................       printf(lcd_putc,"                "); lcd_gotoxy(6,2);
0A7E:  MOVLW  38
0A7F:  BSF    03.6
0A80:  MOVWF  0D
0A81:  MOVLW  01
0A82:  MOVWF  0F
0A83:  BCF    0A.3
0A84:  BCF    03.6
0A85:  CALL   486
0A86:  BSF    0A.3
0A87:  MOVLW  06
0A88:  MOVWF  6F
0A89:  MOVLW  02
0A8A:  MOVWF  70
0A8B:  BCF    0A.3
0A8C:  CALL   250
0A8D:  BSF    0A.3
....................       checkpass= 0;
0A8E:  CLRF   34
....................    }
0A8F:  BCF    0A.3
0A90:  BSF    0A.4
0A91:  GOTO   166 (RETURN)
.................... }
.................... 
.................... void scan_card(){
....................    //lcd_clear();
....................    char UID[6],i,j;
....................    unsigned int TagType; 
....................    matchcard = 0;
*
0800:  CLRF   47
....................    if (MFRC522_isCard (&TagType)){             
0801:  CLRF   72
0802:  MOVLW  70
0803:  MOVWF  71
0804:  BCF    0A.3
0805:  CALL   6A5
0806:  BSF    0A.3
0807:  MOVF   78,F
0808:  BTFSC  03.2
0809:  GOTO   051
....................       if(MFRC522_ReadCardSerial (&UID)){
080A:  CLRF   72
080B:  MOVLW  68
080C:  MOVWF  71
080D:  BCF    0A.3
080E:  CALL   6E2
080F:  BSF    0A.3
0810:  MOVF   78,F
0811:  BTFSC  03.2
0812:  GOTO   04E
....................          card_num = read_eeprom(card_num_add);
0813:  MOVLW  14
0814:  BSF    03.6
0815:  MOVWF  0D
0816:  BSF    03.5
0817:  BCF    0C.7
0818:  BSF    0C.0
0819:  BCF    03.5
081A:  MOVF   0C,W
081B:  BCF    03.6
081C:  MOVWF  48
....................          for(i=0;i<5;i++){/////////////////////////////////////////////////////
081D:  CLRF   6E
081E:  MOVF   6E,W
081F:  SUBLW  04
0820:  BTFSS  03.0
0821:  GOTO   04E
....................             matchcard=0;
0822:  CLRF   47
....................             eeprom_r_pass(card_add+16*i, rightid);
0823:  SWAPF  6E,W
0824:  MOVWF  77
0825:  MOVLW  F0
0826:  ANDWF  77,F
0827:  MOVF   77,W
0828:  ADDLW  24
0829:  MOVWF  71
082A:  MOVWF  72
082B:  CLRF   74
082C:  MOVLW  41
082D:  MOVWF  73
082E:  BCF    0A.3
082F:  CALL   46B
0830:  BSF    0A.3
....................             for(j=0;j<5;j++){
0831:  CLRF   6F
0832:  MOVF   6F,W
0833:  SUBLW  04
0834:  BTFSS  03.0
0835:  GOTO   047
....................                if(UID[j] == rightid[j]) matchcard ++;
0836:  MOVLW  68
0837:  ADDWF  6F,W
0838:  MOVWF  04
0839:  BCF    03.7
083A:  MOVF   00,W
083B:  MOVWF  71
083C:  MOVLW  41
083D:  ADDWF  6F,W
083E:  MOVWF  04
083F:  BCF    03.7
0840:  MOVF   00,W
0841:  SUBWF  71,W
0842:  BTFSS  03.2
0843:  GOTO   045
0844:  INCF   47,F
0845:  INCF   6F,F
0846:  GOTO   032
....................             }
....................             if(matchcard==5){
0847:  MOVF   47,W
0848:  SUBLW  05
0849:  BTFSS  03.2
084A:  GOTO   04C
....................                break;
084B:  GOTO   04E
....................             }
084C:  INCF   6E,F
084D:  GOTO   01E
....................          }
....................       }
....................       MFRC522_Halt() ;          
084E:  BCF    0A.3
084F:  CALL   749
0850:  BSF    0A.3
....................    }
0851:  RETURN
.................... }
.................... 
.................... void check_card(){
....................    if((matchcard % 5) == 0 && matchcard >=5){
*
08B8:  MOVF   47,W
08B9:  MOVWF  6E
08BA:  MOVLW  05
08BB:  MOVWF  6F
08BC:  BCF    0A.3
08BD:  CALL   7DB
08BE:  BSF    0A.3
08BF:  MOVF   77,F
08C0:  BTFSS  03.2
08C1:  GOTO   0CA
08C2:  MOVF   47,W
08C3:  SUBLW  04
08C4:  BTFSC  03.0
08C5:  GOTO   0CA
....................    
....................       unlockdoor();
08C6:  CALL   052
....................       //while(MFRC522_isCard (&TagType));
....................       matchcard=0;
08C7:  CLRF   47
....................       matchpass=7;
08C8:  MOVLW  07
08C9:  MOVWF  46
....................       break;
....................    }
08CA:  RETURN
.................... }
.................... 
.................... void help(){
....................    lcd_clear();
08CB:  BCF    0A.3
08CC:  CALL   7F0
08CD:  BSF    0A.3
....................    lcd_gotoxy(1,1); printf(lcd_putc,"  HOW TO USE?   ");
08CE:  MOVLW  01
08CF:  MOVWF  6F
08D0:  MOVWF  70
08D1:  BCF    0A.3
08D2:  CALL   250
08D3:  BSF    0A.3
08D4:  MOVLW  41
08D5:  BSF    03.6
08D6:  MOVWF  0D
08D7:  MOVLW  01
08D8:  MOVWF  0F
08D9:  BCF    0A.3
08DA:  BCF    03.6
08DB:  CALL   486
08DC:  BSF    0A.3
....................    
....................    while(scan()){
08DD:  BCF    0A.3
08DE:  CALL   4DC
08DF:  BSF    0A.3
08E0:  MOVF   78,F
08E1:  BTFSC  03.2
08E2:  GOTO   181
....................       lcd_gotoxy(1,2);
08E3:  MOVLW  01
08E4:  MOVWF  6F
08E5:  MOVLW  02
08E6:  MOVWF  70
08E7:  BCF    0A.3
08E8:  CALL   250
08E9:  BSF    0A.3
....................       printf(lcd_putc,"A to UNLOCK DOOR");
08EA:  MOVLW  4A
08EB:  BSF    03.6
08EC:  MOVWF  0D
08ED:  MOVLW  01
08EE:  MOVWF  0F
08EF:  BCF    0A.3
08F0:  BCF    03.6
08F1:  CALL   486
08F2:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);
08F3:  MOVLW  0C
08F4:  MOVWF  67
08F5:  MOVLW  FA
08F6:  MOVWF  6A
08F7:  BCF    0A.3
08F8:  CALL   573
08F9:  BSF    0A.3
08FA:  DECFSZ 67,F
08FB:  GOTO   0F5
08FC:  MOVLW  01
08FD:  MOVWF  6F
08FE:  MOVLW  02
08FF:  MOVWF  70
0900:  BCF    0A.3
0901:  CALL   250
0902:  BSF    0A.3
....................       printf(lcd_putc,"B to CHANGE PASS");
0903:  MOVLW  53
0904:  BSF    03.6
0905:  MOVWF  0D
0906:  MOVLW  01
0907:  MOVWF  0F
0908:  BCF    0A.3
0909:  BCF    03.6
090A:  CALL   486
090B:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);
090C:  MOVLW  0C
090D:  MOVWF  67
090E:  MOVLW  FA
090F:  MOVWF  6A
0910:  BCF    0A.3
0911:  CALL   573
0912:  BSF    0A.3
0913:  DECFSZ 67,F
0914:  GOTO   10E
0915:  MOVLW  01
0916:  MOVWF  6F
0917:  MOVLW  02
0918:  MOVWF  70
0919:  BCF    0A.3
091A:  CALL   250
091B:  BSF    0A.3
....................       printf(lcd_putc,"C to ADD NEWCARD");
091C:  MOVLW  5C
091D:  BSF    03.6
091E:  MOVWF  0D
091F:  MOVLW  01
0920:  MOVWF  0F
0921:  BCF    0A.3
0922:  BCF    03.6
0923:  CALL   486
0924:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);
0925:  MOVLW  0C
0926:  MOVWF  67
0927:  MOVLW  FA
0928:  MOVWF  6A
0929:  BCF    0A.3
092A:  CALL   573
092B:  BSF    0A.3
092C:  DECFSZ 67,F
092D:  GOTO   127
092E:  MOVLW  01
092F:  MOVWF  6F
0930:  MOVLW  02
0931:  MOVWF  70
0932:  BCF    0A.3
0933:  CALL   250
0934:  BSF    0A.3
....................       printf(lcd_putc,"D to REMOVE CARD");
0935:  MOVLW  65
0936:  BSF    03.6
0937:  MOVWF  0D
0938:  MOVLW  01
0939:  MOVWF  0F
093A:  BCF    0A.3
093B:  BCF    03.6
093C:  CALL   486
093D:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);
093E:  MOVLW  0C
093F:  MOVWF  67
0940:  MOVLW  FA
0941:  MOVWF  6A
0942:  BCF    0A.3
0943:  CALL   573
0944:  BSF    0A.3
0945:  DECFSZ 67,F
0946:  GOTO   140
0947:  MOVLW  01
0948:  MOVWF  6F
0949:  MOVLW  02
094A:  MOVWF  70
094B:  BCF    0A.3
094C:  CALL   250
094D:  BSF    0A.3
....................       printf(lcd_putc,"* to CLEAR PASS ");
094E:  MOVLW  6E
094F:  BSF    03.6
0950:  MOVWF  0D
0951:  MOVLW  01
0952:  MOVWF  0F
0953:  BCF    0A.3
0954:  BCF    03.6
0955:  CALL   486
0956:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);
0957:  MOVLW  0C
0958:  MOVWF  67
0959:  MOVLW  FA
095A:  MOVWF  6A
095B:  BCF    0A.3
095C:  CALL   573
095D:  BSF    0A.3
095E:  DECFSZ 67,F
095F:  GOTO   159
0960:  MOVLW  01
0961:  MOVWF  6F
0962:  MOVLW  02
0963:  MOVWF  70
0964:  BCF    0A.3
0965:  CALL   250
0966:  BSF    0A.3
....................       printf(lcd_putc,"# to EXIT / BACK");
0967:  MOVLW  77
0968:  BSF    03.6
0969:  MOVWF  0D
096A:  MOVLW  01
096B:  MOVWF  0F
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   486
096F:  BSF    0A.3
....................       delay_ms(3000);   lcd_gotoxy(1,2);      
0970:  MOVLW  0C
0971:  MOVWF  67
0972:  MOVLW  FA
0973:  MOVWF  6A
0974:  BCF    0A.3
0975:  CALL   573
0976:  BSF    0A.3
0977:  DECFSZ 67,F
0978:  GOTO   172
0979:  MOVLW  01
097A:  MOVWF  6F
097B:  MOVLW  02
097C:  MOVWF  70
097D:  BCF    0A.3
097E:  CALL   250
097F:  BSF    0A.3
0980:  GOTO   0DD
....................    }
0981:  BCF    0A.3
0982:  BSF    0A.4
0983:  GOTO   152 (RETURN)
.................... }
.................... 
.................... 
.................... void eeprom_w_pass(unsigned int8 addr,unsigned char*arr)
.................... {
....................    unsigned int8 i;
....................    for(i=0;i<5;i++){
*
0AB7:  CLRF   6B
0AB8:  MOVF   6B,W
0AB9:  SUBLW  04
0ABA:  BTFSS  03.0
0ABB:  GOTO   2E8
....................       write_eeprom(addr+i,*(arr+i)); 
0ABC:  MOVF   6B,W
0ABD:  ADDWF  68,W
0ABE:  MOVWF  6C
0ABF:  MOVF   6B,W
0AC0:  ADDWF  69,W
0AC1:  MOVWF  78
0AC2:  MOVF   6A,W
0AC3:  MOVWF  7A
0AC4:  BTFSC  03.0
0AC5:  INCF   7A,F
0AC6:  MOVF   78,W
0AC7:  MOVWF  04
0AC8:  BCF    03.7
0AC9:  BTFSC  7A.0
0ACA:  BSF    03.7
0ACB:  MOVF   00,W
0ACC:  MOVWF  6D
0ACD:  MOVF   0B,W
0ACE:  MOVWF  77
0ACF:  BCF    0B.7
0AD0:  MOVF   6C,W
0AD1:  BSF    03.6
0AD2:  MOVWF  0D
0AD3:  BCF    03.6
0AD4:  MOVF   6D,W
0AD5:  BSF    03.6
0AD6:  MOVWF  0C
0AD7:  BSF    03.5
0AD8:  BCF    0C.7
0AD9:  BSF    0C.2
0ADA:  MOVLW  55
0ADB:  MOVWF  0D
0ADC:  MOVLW  AA
0ADD:  MOVWF  0D
0ADE:  BSF    0C.1
0ADF:  BTFSC  0C.1
0AE0:  GOTO   2DF
0AE1:  BCF    0C.2
0AE2:  MOVF   77,W
0AE3:  BCF    03.5
0AE4:  BCF    03.6
0AE5:  IORWF  0B,F
0AE6:  INCF   6B,F
0AE7:  GOTO   2B8
....................    }
0AE8:  RETURN
....................    
.................... }
.................... void eeprom_r_pass(unsigned int8 addr, unsigned char*arr)
.................... {
....................    unsigned int8 i;
....................    for(i=0;i<5;i++)
*
046B:  CLRF   75
046C:  MOVF   75,W
046D:  SUBLW  04
046E:  BTFSS  03.0
046F:  GOTO   485
....................    {
....................       arr[i]=read_eeprom(addr+i);
0470:  MOVF   75,W
0471:  ADDWF  73,W
0472:  MOVWF  04
0473:  BCF    03.7
0474:  BTFSC  74.0
0475:  BSF    03.7
0476:  MOVF   75,W
0477:  ADDWF  72,W
0478:  MOVWF  7D
0479:  MOVF   7D,W
047A:  BSF    03.6
047B:  MOVWF  0D
047C:  BSF    03.5
047D:  BCF    0C.7
047E:  BSF    0C.0
047F:  BCF    03.5
0480:  MOVF   0C,W
0481:  MOVWF  00
0482:  INCF   75,F
0483:  BCF    03.6
0484:  GOTO   46C
....................    }
0485:  RETURN
.................... }
.................... 

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
