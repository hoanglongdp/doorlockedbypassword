CCS PCM C Compiler, Version 5.092, 5967               10-Apr-21 13:38

               Filename:   D:\TestProject\TestRFID\TestRFID.lst

               ROM used:   810 words (10%)
                           Largest free fragment is 2048
               RAM used:   25 (7%) at main() level
                           57 (15%) worst case
               Stack used: 3 locations
               Stack size: 8

0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2D1
0003:  NOP
.................... #include <TestRFID.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(crystal=20000000)
.................... 
.................... 
.................... #define MFRC522_CS PIN_E2                 
.................... #define MFRC522_SCK PIN_A2
.................... #define MFRC522_SI  PIN_A1                           
.................... #define MFRC522_SO  PIN_A0              
.................... #define MFRC522_RST PIN_E0    
.................... #include<Built_in.h>     
.................... //#use spi(FORCE_HW,master,baud = 10000000, BITS=8,MSB_FIRST, stream = RFID, ENABLE_ACTIVE=0)// uses hardware SPI and gives this stream the name SPI_STREAM
.................... //MF522 Command word
.................... #define PCD_IDLE              0x00               //NO action; Cancel the current command
.................... #define PCD_AUTHENT           0x0E               //Authentication Key
.................... #define PCD_RECEIVE           0x08               //Receive Data
.................... #define PCD_TRANSMIT          0x04               //Transmit data
.................... #define PCD_TRANSCEIVE        0x0C               //Transmit and receive data,
.................... #define PCD_RESETPHASE        0x0F               //Reset
.................... #define PCD_CALCCRC           0x03               //CRC Calculate
.................... // Mifare_One card command word                 
.................... #define PICC_REQIDL          0x26               // find the antenna area does not enter hibernation
.................... #define PICC_REQALL          0x52               // find all the cards antenna area
.................... #define PICC_ANTICOLL        0x93               // anti-collision
.................... #define PICC_SElECTTAG       0x93               // election card
.................... #define PICC_AUTHENT1A       0x60               // authentication key A
.................... #define PICC_AUTHENT1B       0x61               // authentication key B
.................... #define PICC_READ            0x30               // Read Block
.................... #define PICC_WRITE           0xA0               // write block
.................... #define PICC_DECREMENT       0xC0               // debit
.................... #define PICC_INCREMENT       0xC1               // recharge
.................... #define PICC_RESTORE         0xC2               // transfer block data to the buffer
.................... #define PICC_TRANSFER        0xB0               // save the data in the buffer
.................... #define PICC_HALT            0x50               // Sleep
.................... //And MF522 The error code is returned when communication
.................... #define MI_OK                 0
.................... #define MI_NOTAGERR           1
.................... #define MI_ERR                2
.................... //------------------MFRC522 Register---------------
.................... //Page 0:Command and Status
.................... #define     RESERVED00            0x00    
.................... #define     COMMANDREG            0x01    
.................... #define     COMMIENREG            0x02    
.................... #define     DIVLENREG             0x03    
.................... #define     COMMIRQREG            0x04    
.................... #define     DIVIRQREG             0x05
.................... #define     ERRORREG              0x06    
.................... #define     STATUS1REG            0x07    
.................... #define     STATUS2REG            0x08    
.................... #define     FIFODATAREG           0x09
.................... #define     FIFOLEVELREG          0x0A
.................... #define     WATERLEVELREG         0x0B
.................... #define     CONTROLREG            0x0C
.................... #define     BITFRAMINGREG         0x0D
.................... #define     COLLREG               0x0E
.................... #define     RESERVED01            0x0F
.................... //PAGE 1:Command     
.................... #define     RESERVED10            0x10
.................... #define     MODEREG               0x11
.................... #define     TXMODEREG             0x12
.................... #define     RXMODEREG             0x13
.................... #define     TXCONTROLREG          0x14
.................... #define     TXAUTOREG             0x15
.................... #define     TXSELREG              0x16
.................... #define     RXSELREG              0x17
.................... #define     RXTHRESHOLDREG        0x18
.................... #define     DEMODREG              0x19
.................... #define     RESERVED11            0x1A
.................... #define     RESERVED12            0x1B
.................... #define     MIFAREREG             0x1C
.................... #define     RESERVED13            0x1D
.................... #define     RESERVED14            0x1E
.................... #define     SERIALSPEEDREG        0x1F
.................... //PAGE 2:CFG    
.................... #define     RESERVED20            0x20  
.................... #define     CRCRESULTREGM         0x21
.................... #define     CRCRESULTREGL         0x22
.................... #define     RESERVED21            0x23
.................... #define     MODWIDTHREG           0x24
.................... #define     RESERVED22            0x25
.................... #define     RFCFGREG              0x26
.................... #define     GSNREG                0x27
.................... #define     CWGSPREG              0x28
.................... #define     MODGSPREG             0x29
.................... #define     TMODEREG              0x2A
.................... #define     TPRESCALERREG         0x2B
.................... #define     TRELOADREGH           0x2C
.................... #define     TRELOADREGL           0x2D
.................... #define     TCOUNTERVALUEREGH     0x2E
.................... #define     TCOUNTERVALUEREGL     0x2F
.................... //PAGE 3:TEST REGISTER     
.................... #define     RESERVED30            0x30
.................... #define     TESTSEL1REG           0x31
.................... #define     TESTSEL2REG           0x32
.................... #define     TESTPINENREG          0x33
.................... #define     TESTPINVALUEREG       0x34
.................... #define     TESTBUSREG            0x35
.................... #define     AUTOTESTREG           0x36
.................... #define     VERSIONREG            0x37
.................... #define     ANALOGTESTREG         0x38
.................... #define     TESTDAC1REG           0x39  
.................... #define     TESTDAC2REG           0x3A   
.................... #define     TESTADCREG            0x3B   
.................... #define     RESERVED31            0x3C   
.................... #define     RESERVED32            0x3D   
.................... #define     RESERVED33            0x3E   
.................... #define     RESERVED34            0x3F
.................... static void MFRC522_Wr_Old( char addr, char value )
.................... {
....................         output_bit(MFRC522_CS,0);              
....................         spi_write( ( addr << 1 ) & 0x7E );
....................         spi_write( value );
....................         output_bit(MFRC522_CS,1);
.................... }
.................... static char MFRC522_Rd_Old( char addr )
.................... {
.................... char value;
....................         output_bit(MFRC522_CS,0);                
....................         spi_write( (( addr << 1 ) & 0x7E)|0x80 );
....................         value = spi_read( 0x00 );                            
....................         output_bit(MFRC522_CS,1);     
....................         return value;
.................... } 
.................... 
.................... unsigned int8 MFRC522_Rd(unsigned int8 Address)  
*
0051:  CLRF   51
.................... {
....................    unsigned int i, ucAddr;
....................    unsigned int ucResult = 0;
....................    output_bit (MFRC522_SCK, 0);
0052:  BCF    05.2
0053:  BSF    03.5
0054:  BCF    05.2
....................    output_bit (MFRC522_CS, 0);
0055:  BCF    03.5
0056:  BCF    09.2
0057:  BSF    03.5
0058:  BCF    09.2
....................    ucAddr = ( (Address<<1)&0x7E)|0x80;
0059:  BCF    03.0
005A:  BCF    03.5
005B:  RLF    4E,W
005C:  ANDLW  7E
005D:  IORLW  80
005E:  MOVWF  50
....................    //Write spi
....................    FOR (i = 8; i > 0; i--)
005F:  MOVLW  08
0060:  MOVWF  4F
0061:  MOVF   4F,F
0062:  BTFSC  03.2
0063:  GOTO   07B
....................    {
....................       output_bit (MFRC522_SI, ((ucAddr&0x80) == 0x80));
0064:  MOVF   50,W
0065:  ANDLW  80
0066:  SUBLW  80
0067:  BTFSC  03.2
0068:  GOTO   06B
0069:  BCF    05.1
006A:  GOTO   06C
006B:  BSF    05.1
006C:  BSF    03.5
006D:  BCF    05.1
....................       output_bit (MFRC522_SCK, 1);
006E:  BCF    03.5
006F:  BSF    05.2
0070:  BSF    03.5
0071:  BCF    05.2
....................       ucAddr <<= 1;
0072:  BCF    03.0
0073:  BCF    03.5
0074:  RLF    50,F
....................       output_bit (MFRC522_SCK, 0);
0075:  BCF    05.2
0076:  BSF    03.5
0077:  BCF    05.2
0078:  BCF    03.5
0079:  DECF   4F,F
007A:  GOTO   061
....................    }
.................... //SPI read
....................    FOR (i = 8; i > 0; i--)
007B:  MOVLW  08
007C:  MOVWF  4F
007D:  MOVF   4F,F
007E:  BTFSC  03.2
007F:  GOTO   093
....................    {
....................       output_bit (MFRC522_SCK, 1);
0080:  BSF    05.2
0081:  BSF    03.5
0082:  BCF    05.2
....................       ucResult <<= 1;
0083:  BCF    03.0
0084:  BCF    03.5
0085:  RLF    51,F
....................       ucResult|= (INT1) input (MFRC522_SO);
0086:  BSF    03.5
0087:  BSF    05.0
0088:  MOVLW  00
0089:  BCF    03.5
008A:  BTFSC  05.0
008B:  MOVLW  01
008C:  IORWF  51,F
....................       output_bit (MFRC522_SCK, 0);
008D:  BCF    05.2
008E:  BSF    03.5
008F:  BCF    05.2
0090:  BCF    03.5
0091:  DECF   4F,F
0092:  GOTO   07D
....................    }
.................... 
....................    
....................    output_bit (MFRC522_CS, 1);
0093:  BSF    09.2
0094:  BSF    03.5
0095:  BCF    09.2
....................    output_bit (MFRC522_SCK, 1);
0096:  BCF    03.5
0097:  BSF    05.2
0098:  BSF    03.5
0099:  BCF    05.2
....................    RETURN ucResult;
009A:  BCF    03.5
009B:  MOVF   51,W
009C:  MOVWF  78
009D:  RETURN
.................... }
.................... 
.................... void MFRC522_Wr(unsigned int8 Address, unsigned int8 value)
.................... {
....................    
....................    unsigned int8 i, ucAddr;
....................    output_bit (MFRC522_SCK, 0);
*
0004:  BCF    05.2
0005:  BSF    03.5
0006:  BCF    05.2
....................    output_bit (MFRC522_CS, 0);
0007:  BCF    03.5
0008:  BCF    09.2
0009:  BSF    03.5
000A:  BCF    09.2
....................    ucAddr = ( (Address<<1)&0x7E);
000B:  BCF    03.0
000C:  BCF    03.5
000D:  RLF    4F,W
000E:  ANDLW  7E
000F:  MOVWF  52
....................    FOR (i = 8; i > 0; i--)
0010:  MOVLW  08
0011:  MOVWF  51
0012:  MOVF   51,F
0013:  BTFSC  03.2
0014:  GOTO   02C
....................    {
....................       output_bit (MFRC522_SI, ( (ucAddr&0x80) == 0x80));
0015:  MOVF   52,W
0016:  ANDLW  80
0017:  SUBLW  80
0018:  BTFSC  03.2
0019:  GOTO   01C
001A:  BCF    05.1
001B:  GOTO   01D
001C:  BSF    05.1
001D:  BSF    03.5
001E:  BCF    05.1
....................       output_bit (MFRC522_SCK, 1);
001F:  BCF    03.5
0020:  BSF    05.2
0021:  BSF    03.5
0022:  BCF    05.2
....................       ucAddr <<= 1;
0023:  BCF    03.0
0024:  BCF    03.5
0025:  RLF    52,F
....................       output_bit (MFRC522_SCK, 0);
0026:  BCF    05.2
0027:  BSF    03.5
0028:  BCF    05.2
0029:  BCF    03.5
002A:  DECF   51,F
002B:  GOTO   012
....................    }
.................... 
....................    
....................    FOR (i = 8; i > 0; i--)
002C:  MOVLW  08
002D:  MOVWF  51
002E:  MOVF   51,F
002F:  BTFSC  03.2
0030:  GOTO   048
....................    {
....................       output_bit (MFRC522_SI, ( (value&0x80) == 0x80));
0031:  MOVF   50,W
0032:  ANDLW  80
0033:  SUBLW  80
0034:  BTFSC  03.2
0035:  GOTO   038
0036:  BCF    05.1
0037:  GOTO   039
0038:  BSF    05.1
0039:  BSF    03.5
003A:  BCF    05.1
....................       output_bit (MFRC522_SCK, 1);
003B:  BCF    03.5
003C:  BSF    05.2
003D:  BSF    03.5
003E:  BCF    05.2
....................       value <<= 1;
003F:  BCF    03.0
0040:  BCF    03.5
0041:  RLF    50,F
....................       output_bit (MFRC522_SCK, 0);
0042:  BCF    05.2
0043:  BSF    03.5
0044:  BCF    05.2
0045:  BCF    03.5
0046:  DECF   51,F
0047:  GOTO   02E
....................    }
.................... 
....................    output_bit (MFRC522_CS, 1);
0048:  BSF    09.2
0049:  BSF    03.5
004A:  BCF    09.2
....................    output_bit (MFRC522_SCK, 1);
004B:  BCF    03.5
004C:  BSF    05.2
004D:  BSF    03.5
004E:  BCF    05.2
004F:  BCF    03.5
0050:  RETURN
.................... }
.................... static void MFRC522_Clear_Bit( char addr, char mask )
*
009E:  CLRF   4D
.................... {     unsigned int8  tmp =0x0; 
....................       tmp=MFRC522_Rd( addr ) ;
009F:  MOVF   4B,W
00A0:  MOVWF  4E
00A1:  CALL   051
00A2:  MOVF   78,W
00A3:  MOVWF  4D
....................      MFRC522_Wr( addr,  tmp&~mask );     // tmp&(~mask)
00A4:  MOVF   4C,W
00A5:  XORLW  FF
00A6:  ANDWF  4D,W
00A7:  MOVWF  4E
00A8:  MOVF   4B,W
00A9:  MOVWF  4F
00AA:  MOVF   4E,W
00AB:  MOVWF  50
00AC:  CALL   004
00AD:  RETURN
.................... }
.................... static void MFRC522_Set_Bit( char addr, char mask )
00AE:  CLRF   4D
.................... {    unsigned int8  tmp =0x0; 
....................       tmp=MFRC522_Rd( addr ) ;  
00AF:  MOVF   4B,W
00B0:  MOVWF  4E
00B1:  CALL   051
00B2:  MOVF   78,W
00B3:  MOVWF  4D
....................      MFRC522_Wr( addr, tmp|mask );
00B4:  MOVF   4D,W
00B5:  IORWF  4C,W
00B6:  MOVWF  4E
00B7:  MOVF   4B,W
00B8:  MOVWF  4F
00B9:  MOVF   4E,W
00BA:  MOVWF  50
00BB:  CALL   004
00BC:  RETURN
.................... }
.................... void MFRC522_Reset()
.................... {  
....................    output_bit (MFRC522_RST, 1) ;
*
00C4:  BCF    03.5
00C5:  BSF    09.0
00C6:  BSF    03.5
00C7:  BCF    09.0
....................    delay_us (1);
00C8:  GOTO   0C9
00C9:  GOTO   0CA
00CA:  NOP
....................    output_bit (MFRC522_RST, 0) ;
00CB:  BCF    03.5
00CC:  BCF    09.0
00CD:  BSF    03.5
00CE:  BCF    09.0
....................    delay_us (1);
00CF:  GOTO   0D0
00D0:  GOTO   0D1
00D1:  NOP
....................    output_bit (MFRC522_RST, 1) ;
00D2:  BCF    03.5
00D3:  BSF    09.0
00D4:  BSF    03.5
00D5:  BCF    09.0
....................    delay_us (1);
00D6:  GOTO   0D7
00D7:  GOTO   0D8
00D8:  NOP
....................    MFRC522_Wr( COMMANDREG, PCD_RESETPHASE ); 
00D9:  MOVLW  01
00DA:  BCF    03.5
00DB:  MOVWF  4F
00DC:  MOVLW  0F
00DD:  MOVWF  50
00DE:  CALL   004
....................    delay_us (1);
00DF:  GOTO   0E0
00E0:  GOTO   0E1
00E1:  NOP
.................... }
.................... void MFRC522_AntennaOn()
.................... {                                               
.................... unsigned int8 stt;
.................... stt= MFRC522_Rd( TXCONTROLREG ) ;
*
0104:  MOVLW  14
0105:  MOVWF  4E
0106:  CALL   051
0107:  MOVF   78,W
0108:  MOVWF  34
.................... MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
0109:  MOVLW  14
010A:  MOVWF  4B
010B:  MOVLW  03
010C:  MOVWF  4C
010D:  CALL   0AE
.................... //!if(! (stt&0x03)){                                     
.................... //! MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
.................... //!}
.................... }
.................... void MFRC522_AntennaOff()
.................... {
....................  MFRC522_Clear_Bit( TXCONTROLREG, 0x03 );                                           
*
00FF:  MOVLW  14
0100:  MOVWF  4B
0101:  MOVLW  03
0102:  MOVWF  4C
0103:  CALL   09E
.................... }
.................... void MFRC522_Init()      
.................... {
....................                                                               
....................     output_bit(MFRC522_CS , 1);  
*
00BD:  BSF    09.2
00BE:  BSF    03.5
00BF:  BCF    09.2
....................     output_bit( MFRC522_RST , 1); 
00C0:  BCF    03.5
00C1:  BSF    09.0
00C2:  BSF    03.5
00C3:  BCF    09.0
....................     
....................      MFRC522_Reset();        
....................      MFRC522_Wr( TMODEREG, 0x8D );      //Tauto=1; f(Timer) = 6.78MHz/TPreScaler
*
00E2:  MOVLW  2A
00E3:  MOVWF  4F
00E4:  MOVLW  8D
00E5:  MOVWF  50
00E6:  CALL   004
....................      MFRC522_Wr( TPRESCALERREG, 0x3E ); //TModeReg[3..0] + TPrescalerReg 
00E7:  MOVLW  2B
00E8:  MOVWF  4F
00E9:  MOVLW  3E
00EA:  MOVWF  50
00EB:  CALL   004
....................      MFRC522_Wr( TRELOADREGL, 30 ); 
00EC:  MOVLW  2D
00ED:  MOVWF  4F
00EE:  MOVLW  1E
00EF:  MOVWF  50
00F0:  CALL   004
....................      MFRC522_Wr( TRELOADREGH, 0 );  
00F1:  MOVLW  2C
00F2:  MOVWF  4F
00F3:  CLRF   50
00F4:  CALL   004
....................      MFRC522_Wr( TXAUTOREG, 0x40 );    //100%ASK
00F5:  MOVLW  15
00F6:  MOVWF  4F
00F7:  MOVLW  40
00F8:  MOVWF  50
00F9:  CALL   004
....................      MFRC522_Wr( MODEREG, 0x3D );      // CRC valor inicial de 0x6363
00FA:  MOVLW  11
00FB:  MOVWF  4F
00FC:  MOVLW  3D
00FD:  MOVWF  50
00FE:  CALL   004
....................         
....................      //MFRC522_Clear_Bit( STATUS2REG, 0x08 );//MFCrypto1On=0
....................      //MFRC522_Wr( RXSELREG, 0x86 );      //RxWait = RxSelReg[5..0]
....................      //MFRC522_Wr( RFCFGREG, 0x7F );     //RxGain = 48dB
....................      MFRC522_AntennaOff() ;             
....................      MFRC522_AntennaOn();
*
010E:  BCF    0A.3
010F:  BCF    0A.4
0110:  GOTO   2F4 (RETURN)
.................... }
.................... char MFRC522_ToCard( char command, char *sendData, char sendLen, char *backData, unsigned *backLen )
0111:  MOVLW  02
0112:  MOVWF  45
0113:  CLRF   46
0114:  CLRF   47
.................... {
....................   char _status = MI_ERR;
....................   char irqEn = 0x00;
....................   char waitIRq = 0x00;                
....................   char lastBits;
....................   char n;
....................   unsigned i;
....................   
....................   switch (command)
0115:  MOVF   3D,W
0116:  XORLW  0E
0117:  BTFSC  03.2
0118:  GOTO   11D
0119:  XORLW  02
011A:  BTFSC  03.2
011B:  GOTO   122
011C:  GOTO   127
....................   {
....................     case PCD_AUTHENT:       //Certification cards close
....................     {
....................       irqEn = 0x12;
011D:  MOVLW  12
011E:  MOVWF  46
....................       waitIRq = 0x10;
011F:  MOVLW  10
0120:  MOVWF  47
....................       break;
0121:  GOTO   127
....................     }
....................     case PCD_TRANSCEIVE:    //Transmit FIFO data
....................     {
....................       irqEn = 0x77;
0122:  MOVLW  77
0123:  MOVWF  46
....................       waitIRq = 0x30;
0124:  MOVLW  30
0125:  MOVWF  47
....................       break;
0126:  GOTO   127
....................     }
....................     default:
....................       break;
....................   }
....................   MFRC522_Wr( COMMIENREG, irqEn | 0x80 );  //Interrupt request
0127:  MOVF   46,W
0128:  IORLW  80
0129:  MOVWF  4B
012A:  MOVLW  02
012B:  MOVWF  4F
012C:  MOVF   4B,W
012D:  MOVWF  50
012E:  CALL   004
....................   MFRC522_Clear_Bit( COMMIRQREG, 0x80 );   //Clear all interrupt request bit
012F:  MOVLW  04
0130:  MOVWF  4B
0131:  MOVLW  80
0132:  MOVWF  4C
0133:  CALL   09E
....................   MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );   //FlushBuffer=1, FIFO Initialization
0134:  MOVLW  0A
0135:  MOVWF  4B
0136:  MOVLW  80
0137:  MOVWF  4C
0138:  CALL   0AE
....................   MFRC522_Wr( COMMANDREG, PCD_IDLE );      //NO action; Cancel the current command???
0139:  MOVLW  01
013A:  MOVWF  4F
013B:  CLRF   50
013C:  CALL   004
....................   
....................   
....................   
....................   //Writing data to the FIFO
....................   for ( i=0; i < sendLen; i++ )
013D:  CLRF   4A
013E:  MOVF   40,W
013F:  SUBWF  4A,W
0140:  BTFSC  03.0
0141:  GOTO   151
....................   {
....................     MFRC522_Wr( FIFODATAREG, sendData[i] );
0142:  MOVF   4A,W
0143:  ADDWF  3E,W
0144:  MOVWF  04
0145:  BCF    03.7
0146:  BTFSC  3F.0
0147:  BSF    03.7
0148:  MOVF   00,W
0149:  MOVWF  4B
014A:  MOVLW  09
014B:  MOVWF  4F
014C:  MOVF   4B,W
014D:  MOVWF  50
014E:  CALL   004
014F:  INCF   4A,F
0150:  GOTO   13E
....................   }
....................   //Execute the command
....................   MFRC522_Wr( COMMANDREG, command );
0151:  MOVLW  01
0152:  MOVWF  4F
0153:  MOVF   3D,W
0154:  MOVWF  50
0155:  CALL   004
....................   if (command == PCD_TRANSCEIVE )
0156:  MOVF   3D,W
0157:  SUBLW  0C
0158:  BTFSS  03.2
0159:  GOTO   15F
....................   {
....................     MFRC522_Set_Bit( BITFRAMINGREG, 0x80 ); //StartSend=1,transmission of data starts  
015A:  MOVLW  0D
015B:  MOVWF  4B
015C:  MOVLW  80
015D:  MOVWF  4C
015E:  CALL   0AE
....................   }
....................   //Waiting to receive data to complete
....................   //i according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
....................   i = 0xFFFF;   
015F:  MOVLW  FF
0160:  MOVWF  4A
....................   do
....................   {
....................     //CommIrqReg[7..0]
....................     //Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
....................     n = MFRC522_Rd( COMMIRQREG );
0161:  MOVLW  04
0162:  MOVWF  4E
0163:  CALL   051
0164:  MOVF   78,W
0165:  MOVWF  49
....................     i--;
0166:  DECF   4A,F
....................   }
....................   while ( i && !(n & 0x01) && !( n & waitIRq ) );
0167:  MOVF   4A,F
0168:  BTFSC  03.2
0169:  GOTO   170
016A:  BTFSC  49.0
016B:  GOTO   170
016C:  MOVF   49,W
016D:  ANDWF  47,W
016E:  BTFSC  03.2
016F:  GOTO   161
....................   MFRC522_Clear_Bit( BITFRAMINGREG, 0x80 );    //StartSend=0
0170:  MOVLW  0D
0171:  MOVWF  4B
0172:  MOVLW  80
0173:  MOVWF  4C
0174:  CALL   09E
....................   if (i != 0)
0175:  MOVF   4A,F
0176:  BTFSC  03.2
0177:  GOTO   1E8
....................   {
....................     if( !( MFRC522_Rd( ERRORREG ) & 0x1B ) ) //BufferOvfl Collerr CRCErr ProtecolErr
0178:  MOVLW  06
0179:  MOVWF  4E
017A:  CALL   051
017B:  MOVF   78,W
017C:  ANDLW  1B
017D:  BTFSS  03.2
017E:  GOTO   1E6
....................     {
....................       _status = MI_OK;
017F:  CLRF   45
....................       if ( n & irqEn & 0x01 )
0180:  MOVF   49,W
0181:  ANDWF  46,W
0182:  ANDLW  01
0183:  BTFSC  03.2
0184:  GOTO   187
....................       {
....................         _status = MI_NOTAGERR;       //??
0185:  MOVLW  01
0186:  MOVWF  45
....................       }
....................       if ( command == PCD_TRANSCEIVE )
0187:  MOVF   3D,W
0188:  SUBLW  0C
0189:  BTFSS  03.2
018A:  GOTO   1E5
....................       {
....................         n = MFRC522_Rd( FIFOLEVELREG );
018B:  MOVLW  0A
018C:  MOVWF  4E
018D:  CALL   051
018E:  MOVF   78,W
018F:  MOVWF  49
....................         lastBits = MFRC522_Rd( CONTROLREG ) & 0x07;
0190:  MOVLW  0C
0191:  MOVWF  4E
0192:  CALL   051
0193:  MOVF   78,W
0194:  ANDLW  07
0195:  MOVWF  48
....................         if (lastBits)
0196:  MOVF   48,F
0197:  BTFSC  03.2
0198:  GOTO   1AA
....................         {
....................           *backLen = (n-1) * 8 + lastBits;
0199:  MOVF   43,W
019A:  MOVWF  04
019B:  BCF    03.7
019C:  BTFSC  44.0
019D:  BSF    03.7
019E:  MOVLW  01
019F:  SUBWF  49,W
01A0:  MOVWF  77
01A1:  RLF    77,F
01A2:  RLF    77,F
01A3:  RLF    77,F
01A4:  MOVLW  F8
01A5:  ANDWF  77,F
01A6:  MOVF   77,W
01A7:  ADDWF  48,W
01A8:  MOVWF  00
....................         }
01A9:  GOTO   1B7
....................         else
....................         {
....................           *backLen = n * 8;
01AA:  MOVF   43,W
01AB:  MOVWF  04
01AC:  BCF    03.7
01AD:  BTFSC  44.0
01AE:  BSF    03.7
01AF:  RLF    49,W
01B0:  MOVWF  77
01B1:  RLF    77,F
01B2:  RLF    77,F
01B3:  MOVLW  F8
01B4:  ANDWF  77,F
01B5:  MOVF   77,W
01B6:  MOVWF  00
....................         }
....................         if (n == 0)
01B7:  MOVF   49,F
01B8:  BTFSS  03.2
01B9:  GOTO   1BC
....................         {
....................           n = 1;
01BA:  MOVLW  01
01BB:  MOVWF  49
....................         }
....................         if (n > 16)
01BC:  MOVF   49,W
01BD:  SUBLW  10
01BE:  BTFSC  03.0
01BF:  GOTO   1C2
....................         {
....................           n = 16;
01C0:  MOVLW  10
01C1:  MOVWF  49
....................         }
....................         //Reading the received data in FIFO
....................         for (i=0; i < n; i++)
01C2:  CLRF   4A
01C3:  MOVF   49,W
01C4:  SUBWF  4A,W
01C5:  BTFSC  03.0
01C6:  GOTO   1DE
....................         {
....................           backData[i] = MFRC522_Rd( FIFODATAREG );
01C7:  MOVF   4A,W
01C8:  ADDWF  41,W
01C9:  MOVWF  78
01CA:  MOVF   42,W
01CB:  MOVWF  7A
01CC:  BTFSC  03.0
01CD:  INCF   7A,F
01CE:  MOVF   78,W
01CF:  MOVWF  4B
01D0:  MOVF   7A,W
01D1:  MOVWF  4C
01D2:  MOVLW  09
01D3:  MOVWF  4E
01D4:  CALL   051
01D5:  MOVF   4B,W
01D6:  MOVWF  04
01D7:  BCF    03.7
01D8:  BTFSC  4C.0
01D9:  BSF    03.7
01DA:  MOVF   78,W
01DB:  MOVWF  00
01DC:  INCF   4A,F
01DD:  GOTO   1C3
....................         }
....................   
....................   backData[i] = 0;
01DE:  MOVF   4A,W
01DF:  ADDWF  41,W
01E0:  MOVWF  04
01E1:  BCF    03.7
01E2:  BTFSC  42.0
01E3:  BSF    03.7
01E4:  CLRF   00
....................       }
....................     }
01E5:  GOTO   1E8
....................     else
....................     {
....................       _status = MI_ERR;
01E6:  MOVLW  02
01E7:  MOVWF  45
....................     }
....................   }
....................   //MFRC522_Set_Bit( CONTROLREG, 0x80 );
....................   //MFRC522_Wr( COMMANDREG, PCD_IDLE );
....................   return _status;
01E8:  MOVF   45,W
01E9:  MOVWF  78
01EA:  RETURN
.................... }
.................... char MFRC522_Request( char reqMode, char *TagType )
.................... {
....................   char _status;
....................   unsigned backBits;            //The received data bits
....................   MFRC522_Wr( BITFRAMINGREG, 0x07 ); //TxLastBists = BitFramingReg[2..0]   ???
*
01F1:  MOVLW  0D
01F2:  MOVWF  4F
01F3:  MOVLW  07
01F4:  MOVWF  50
01F5:  CALL   004
....................   TagType[0] = reqMode;
01F6:  MOVF   37,W
01F7:  MOVWF  04
01F8:  BCF    03.7
01F9:  BTFSC  38.0
01FA:  BSF    03.7
01FB:  MOVF   36,W
01FC:  MOVWF  00
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, TagType, 1, TagType, &backBits );
01FD:  MOVLW  0C
01FE:  MOVWF  3D
01FF:  MOVF   38,W
0200:  MOVWF  3F
0201:  MOVF   37,W
0202:  MOVWF  3E
0203:  MOVLW  01
0204:  MOVWF  40
0205:  MOVF   38,W
0206:  MOVWF  42
0207:  MOVF   37,W
0208:  MOVWF  41
0209:  CLRF   44
020A:  MOVLW  3A
020B:  MOVWF  43
020C:  CALL   111
020D:  MOVF   78,W
020E:  MOVWF  39
....................   if ( (_status != MI_OK) || (backBits != 0x10) )
020F:  MOVF   39,F
0210:  BTFSS  03.2
0211:  GOTO   216
0212:  MOVF   3A,W
0213:  SUBLW  10
0214:  BTFSC  03.2
0215:  GOTO   218
....................   {
....................     _status = MI_ERR;
0216:  MOVLW  02
0217:  MOVWF  39
....................   }
....................   return _status;
0218:  MOVF   39,W
0219:  MOVWF  78
.................... }
.................... void MFRC522_CRC( char *dataIn, char length, char *dataOut )
.................... {
.................... char i, n;
....................     MFRC522_Clear_Bit( DIVIRQREG, 0x04 );
....................     MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );    
....................     
....................  //Escreve dados no FIFO        
....................     for ( i = 0; i < length; i++ )
....................     {   
....................         MFRC522_Wr( FIFODATAREG, *dataIn++ );   
....................     }
....................     
....................     MFRC522_Wr( COMMANDREG, PCD_CALCCRC );
....................         
....................     i = 0xFF;
....................     //Espera a finalização do Calculo do CRC
....................     do 
....................     {
....................         n = MFRC522_Rd( DIVIRQREG );
....................         i--;
....................     }
....................     while( i && !(n & 0x04) );        //CRCIrq = 1
....................         
....................     dataOut[0] = MFRC522_Rd( CRCRESULTREGL );
....................     dataOut[1] = MFRC522_Rd( CRCRESULTREGM );        
.................... }
.................... char MFRC522_SelectTag( char *serNum )
.................... {
....................   char i;
....................   char _status;
....................   char size;
....................   unsigned recvBits;
....................   char buffer[9];
....................   
....................   //MFRC522_Clear_Bit( STATUS2REG, 0x08 );   //MFCrypto1On=0
....................   
....................   buffer[0] = PICC_SElECTTAG;
....................   buffer[1] = 0x70;
....................   
....................   for ( i=2; i < 7; i++ )
....................   {
....................     buffer[i] = *serNum++;
....................   }
....................   
....................   MFRC522_CRC( buffer, 7, &buffer[7] );             
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits );
....................   if ( (_status == MI_OK) && (recvBits == 0x18) )
....................   {
....................     size = buffer[0];
....................   }
....................   else
....................   {
....................     size = 0;
....................   }
....................   return size;
.................... }
.................... //hibernation
.................... void MFRC522_Halt()
.................... {
....................   unsigned unLen;
....................   char buff[4];
....................   
....................   buff[0] = PICC_HALT;
....................   buff[1] = 0;
....................   MFRC522_CRC( buff, 2, &buff[2] );
....................   MFRC522_Clear_Bit( STATUS2REG, 0x80 );
....................   MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &unLen );
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
.................... }
.................... char MFRC522_Auth( char authMode, char BlockAddr, char *Sectorkey, char *serNum )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[12];
....................   
....................   //Verify the command block address + sector + password + card serial number
....................   buff[0] = authMode;
....................   buff[1] = BlockAddr;
....................   
....................   for ( i = 2; i < 8; i++ )
....................   {
....................     buff[i] = Sectorkey[i-2];
....................   }
....................   
....................   for ( i = 8; i < 12; i++ )
....................   {
....................     buff[i] = serNum[i-8];
....................   }
....................   
....................   _status = MFRC522_ToCard( PCD_AUTHENT, buff, 12, buff, &recvBits );
....................   
....................   if ( ( _status != MI_OK ) || !( MFRC522_Rd( STATUS2REG ) & 0x08 ) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   
....................   return _status;
.................... }
.................... char MFRC522_Write( char blockAddr, char *writeData )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[18];
....................   buff[0] = PICC_WRITE;
....................   buff[1] = blockAddr;
....................   
....................   MFRC522_CRC( buff, 2, &buff[2] );
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &recvBits );
....................   if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   if (_status == MI_OK)
....................   {
....................     for ( i = 0; i < 16; i++ )                //Data to the FIFO write 16Byte
....................     {
....................       buff[i] = writeData[i];
....................     }
....................     
....................     MFRC522_CRC( buff, 16, &buff[16] );
....................     _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 18, buff, &recvBits );
....................     if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A ) )
....................     {
....................       _status = MI_ERR;
....................     }
....................   }
....................   return _status;
.................... }
.................... char MFRC522_Read( char blockAddr, char *recvData )
.................... {
....................   char _status;
....................   unsigned unLen;
....................   recvData[0] = PICC_READ;
....................   recvData[1] = blockAddr;
....................   
....................   MFRC522_CRC( recvData, 2, &recvData[2] );
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, recvData, 4, recvData, &unLen );
....................   if ( (_status != MI_OK) || (unLen != 0x90) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   return _status;
.................... }
.................... char MFRC522_AntiColl( char *serNum )
*
022A:  CLRF   3B
.................... {
....................   char _status;
....................   char i;
....................   char serNumCheck = 0;
....................   unsigned unLen;
....................   MFRC522_Wr( BITFRAMINGREG, 0x00 );                //TxLastBists = BitFramingReg[2..0]
022B:  MOVLW  0D
022C:  MOVWF  4F
022D:  CLRF   50
022E:  CALL   004
....................   serNum[0] = PICC_ANTICOLL;
022F:  MOVF   37,W
0230:  MOVWF  04
0231:  BCF    03.7
0232:  BTFSC  38.0
0233:  BSF    03.7
0234:  MOVLW  93
0235:  MOVWF  00
....................   serNum[1] = 0x20;
0236:  MOVLW  01
0237:  ADDWF  37,W
0238:  MOVWF  04
0239:  BCF    03.7
023A:  BTFSC  38.0
023B:  BSF    03.7
023C:  MOVLW  20
023D:  MOVWF  00
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
023E:  MOVLW  08
023F:  MOVWF  4B
0240:  MOVWF  4C
0241:  CALL   09E
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, serNum, 2, serNum, &unLen );
0242:  MOVLW  0C
0243:  MOVWF  3D
0244:  MOVF   38,W
0245:  MOVWF  3F
0246:  MOVF   37,W
0247:  MOVWF  3E
0248:  MOVLW  02
0249:  MOVWF  40
024A:  MOVF   38,W
024B:  MOVWF  42
024C:  MOVF   37,W
024D:  MOVWF  41
024E:  CLRF   44
024F:  MOVLW  3C
0250:  MOVWF  43
0251:  CALL   111
0252:  MOVF   78,W
0253:  MOVWF  39
....................   if (_status == MI_OK)
0254:  MOVF   39,F
0255:  BTFSS  03.2
0256:  GOTO   272
....................   {
....................     for ( i=0; i < 4; i++ )
0257:  CLRF   3A
0258:  MOVF   3A,W
0259:  SUBLW  03
025A:  BTFSS  03.0
025B:  GOTO   266
....................     {
....................       serNumCheck ^= serNum[i];
025C:  MOVF   3A,W
025D:  ADDWF  37,W
025E:  MOVWF  04
025F:  BCF    03.7
0260:  BTFSC  38.0
0261:  BSF    03.7
0262:  MOVF   00,W
0263:  XORWF  3B,F
0264:  INCF   3A,F
0265:  GOTO   258
....................     }
....................     
....................     if ( serNumCheck != serNum[4] )
0266:  MOVLW  04
0267:  ADDWF  37,W
0268:  MOVWF  04
0269:  BCF    03.7
026A:  BTFSC  38.0
026B:  BSF    03.7
026C:  MOVF   00,W
026D:  SUBWF  3B,W
026E:  BTFSC  03.2
026F:  GOTO   272
....................     {
....................       _status = MI_ERR;
0270:  MOVLW  02
0271:  MOVWF  39
....................     }
....................   }
....................   return _status;
0272:  MOVF   39,W
0273:  MOVWF  78
.................... }
.................... //0x0044 = Mifare_UltraLight
.................... //0x0004 = Mifare_One (S50)
.................... //0x0002 = Mifare_One (S70)
.................... //0x0008 = Mifare_Pro (X)
.................... //0x0344 = Mifare_DESFire
.................... char MFRC522_isCard( char *TagType ) 
.................... {
....................     if (MFRC522_Request( PICC_REQIDL, TagType ) == MI_OK)
*
01EB:  MOVLW  26
01EC:  MOVWF  36
01ED:  MOVF   35,W
01EE:  MOVWF  38
01EF:  MOVF   34,W
01F0:  MOVWF  37
*
021A:  MOVF   78,F
021B:  BTFSS  03.2
021C:  GOTO   221
....................         return 1;
021D:  MOVLW  01
021E:  MOVWF  78
021F:  GOTO   223
0220:  GOTO   223
....................     else
....................         return 0; 
0221:  MOVLW  00
0222:  MOVWF  78
0223:  BCF    0A.3
0224:  BCF    0A.4
0225:  GOTO   2F8 (RETURN)
.................... }
.................... char MFRC522_ReadCardSerial( char *str )
.................... {
.................... char _status; 
....................  _status = MFRC522_AntiColl( str );
0226:  MOVF   35,W
0227:  MOVWF  38
0228:  MOVF   34,W
0229:  MOVWF  37
*
0274:  MOVF   78,W
0275:  MOVWF  36
....................  str[5] = 0;
0276:  MOVLW  05
0277:  ADDWF  34,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  BTFSC  35.0
027B:  BSF    03.7
027C:  CLRF   00
....................  if (_status == MI_OK)
027D:  MOVF   36,F
027E:  BTFSS  03.2
027F:  GOTO   284
....................   return 1;
0280:  MOVLW  01
0281:  MOVWF  78
0282:  GOTO   286
0283:  GOTO   286
....................  else
....................   return 0;
0284:  MOVLW  00
0285:  MOVWF  78
0286:  BCF    0A.3
0287:  BCF    0A.4
0288:  GOTO   2FF (RETURN)
.................... }
.................... 
.................... char RedData[6] ={0x43,0xA8,0xF2,0x02};
*
02DE:  MOVLW  43
02DF:  BCF    03.5
02E0:  MOVWF  20
02E1:  MOVLW  A8
02E2:  MOVWF  21
02E3:  MOVLW  F2
02E4:  MOVWF  22
02E5:  MOVLW  02
02E6:  MOVWF  23
02E7:  CLRF   24
02E8:  CLRF   25
.................... char BlueData[6] ={0xAA,0x61,0xDF,0x80}; 
02E9:  MOVLW  AA
02EA:  MOVWF  26
02EB:  MOVLW  61
02EC:  MOVWF  27
02ED:  MOVLW  DF
02EE:  MOVWF  28
02EF:  MOVLW  80
02F0:  MOVWF  29
02F1:  CLRF   2A
02F2:  CLRF   2B
.................... int1 red=0,blue=0;
.................... int1 get_red(char Data[],char UID[] )
.................... {
....................  FOR (int i = 0; i < 4; i++)                  
*
0289:  CLRF   38
028A:  MOVF   38,W
028B:  SUBLW  03
028C:  BTFSS  03.0
028D:  GOTO   2A6
....................    {   
....................       if(UID[i]== Data[i] )
028E:  MOVF   38,W
028F:  ADDWF  36,W
0290:  MOVWF  04
0291:  BCF    03.7
0292:  BTFSC  37.0
0293:  BSF    03.7
0294:  MOVF   00,W
0295:  MOVWF  39
0296:  MOVF   38,W
0297:  ADDWF  34,W
0298:  MOVWF  04
0299:  BCF    03.7
029A:  BTFSC  35.0
029B:  BSF    03.7
029C:  MOVF   00,W
029D:  SUBWF  39,W
029E:  BTFSS  03.2
029F:  GOTO   2A2
....................       {                                   
....................          red=1; 
02A0:  BSF    2C.0
....................       } 
02A1:  GOTO   2A4
....................       else                                             
....................       {
....................          red=0;
02A2:  BCF    2C.0
....................          break;
02A3:  GOTO   2A6
....................       }        
02A4:  INCF   38,F
02A5:  GOTO   28A
....................    } 
....................    return red;
02A6:  MOVLW  00
02A7:  BTFSC  2C.0
02A8:  MOVLW  01
02A9:  MOVWF  78
02AA:  BCF    0A.3
02AB:  BCF    0A.4
02AC:  GOTO   309 (RETURN)
.................... }
.................... int1 get_blue(char Data[],char UID[] )
.................... {
....................  FOR (int i = 0; i < 4; i++)                  
02AD:  CLRF   38
02AE:  MOVF   38,W
02AF:  SUBLW  03
02B0:  BTFSS  03.0
02B1:  GOTO   2CA
....................    {   
....................       if(UID[i]== Data[i] )
02B2:  MOVF   38,W
02B3:  ADDWF  36,W
02B4:  MOVWF  04
02B5:  BCF    03.7
02B6:  BTFSC  37.0
02B7:  BSF    03.7
02B8:  MOVF   00,W
02B9:  MOVWF  39
02BA:  MOVF   38,W
02BB:  ADDWF  34,W
02BC:  MOVWF  04
02BD:  BCF    03.7
02BE:  BTFSC  35.0
02BF:  BSF    03.7
02C0:  MOVF   00,W
02C1:  SUBWF  39,W
02C2:  BTFSS  03.2
02C3:  GOTO   2C6
....................       {                                   
....................          blue=1; 
02C4:  BSF    2C.1
....................       } 
02C5:  GOTO   2C8
....................       else                                             
....................       {
....................          blue=0;
02C6:  BCF    2C.1
....................          break;
02C7:  GOTO   2CA
....................       }        
02C8:  INCF   38,F
02C9:  GOTO   2AE
....................    } 
....................    return blue;
02CA:  MOVLW  00
02CB:  BTFSC  2C.1
02CC:  MOVLW  01
02CD:  MOVWF  78
02CE:  BCF    0A.3
02CF:  BCF    0A.4
02D0:  GOTO   31C (RETURN)
.................... }   
.................... void main()
02D1:  MOVF   03,W
02D2:  ANDLW  1F
02D3:  MOVWF  03
02D4:  BCF    2C.0
02D5:  BCF    2C.1
02D6:  BSF    03.5
02D7:  BSF    1F.0
02D8:  BSF    1F.1
02D9:  BSF    1F.2
02DA:  BCF    1F.3
02DB:  MOVLW  07
02DC:  MOVWF  1C
02DD:  BCF    03.7
.................... {
....................    char UID[6];
....................    MFRC522_Init ();
*
02F3:  GOTO   0BD
....................    unsigned int TagType;
....................    
....................    while(TRUE)
....................    {
....................       if (MFRC522_isCard (&TagType))
02F4:  CLRF   35
02F5:  MOVLW  33
02F6:  MOVWF  34
02F7:  GOTO   1EB
02F8:  MOVF   78,F
02F9:  BTFSC  03.2
02FA:  GOTO   328
....................       {
....................          if (MFRC522_ReadCardSerial (&UID)) 
02FB:  CLRF   35
02FC:  MOVLW  2D
02FD:  MOVWF  34
02FE:  GOTO   226
02FF:  MOVF   78,F
0300:  BTFSC  03.2
0301:  GOTO   328
....................          {
....................             if(get_red(RedData,UID))
0302:  CLRF   35
0303:  MOVLW  20
0304:  MOVWF  34
0305:  CLRF   37
0306:  MOVLW  2D
0307:  MOVWF  36
0308:  GOTO   289
0309:  MOVF   78,F
030A:  BTFSC  03.2
030B:  GOTO   311
....................             {
....................                output_low(pin_D0);
030C:  BSF    03.5
030D:  BCF    08.0
030E:  BCF    03.5
030F:  BCF    08.0
....................                
....................             }
0310:  GOTO   315
....................             else
....................             {
....................                output_high(pin_D0);
0311:  BSF    03.5
0312:  BCF    08.0
0313:  BCF    03.5
0314:  BSF    08.0
....................             }
....................             if(get_blue(BlueData,UID))
0315:  CLRF   35
0316:  MOVLW  26
0317:  MOVWF  34
0318:  CLRF   37
0319:  MOVLW  2D
031A:  MOVWF  36
031B:  GOTO   2AD
031C:  MOVF   78,F
031D:  BTFSC  03.2
031E:  GOTO   324
....................             {
....................                output_low(pin_D1);
031F:  BSF    03.5
0320:  BCF    08.1
0321:  BCF    03.5
0322:  BCF    08.1
....................             }
0323:  GOTO   328
....................             else
....................             {
....................                output_high(pin_D1);
0324:  BSF    03.5
0325:  BCF    08.1
0326:  BCF    03.5
0327:  BSF    08.1
....................             }
....................          }
....................          
....................       }
0328:  GOTO   2F4
.................... 
....................       //TODO: User Code
....................    }
.................... 
.................... }
0329:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
